<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpNeat</name>
    </assembly>
    <members>
        <member name="T:SharpNeat.ConfigurationException">
            <summary>
            Represents a problem with configuration data.
            </summary>
        </member>
        <member name="M:SharpNeat.ConfigurationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpNeat.ConfigurationException"/> class.
            </summary>
            <param name="message">A message describing why this exception was thrown.</param>
        </member>
        <member name="M:SharpNeat.ConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpNeat.ConfigurationException"/> class.
            </summary>
            <param name="message">A message describing why this exception was thrown.</param>
            <param name="innerException">The inner exception that caused this ConfigurationException to be thrown,
            if any.</param>
        </member>
        <member name="T:SharpNeat.Evaluation.FitnessInfo">
            <summary>
            Represents fitness information for a genome.
            </summary>
        </member>
        <member name="F:SharpNeat.Evaluation.FitnessInfo.DefaultFitnessInfo">
            <summary>
            Default singleton instance.
            </summary>
        </member>
        <member name="M:SharpNeat.Evaluation.FitnessInfo.#ctor(System.Double)">
            <summary>
            Construct with a single fitness score.
            </summary>
            <param name="fitness">Genome fitness score.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.FitnessInfo.#ctor(System.Double,System.Double[])">
            <summary>
            Construct with a compound fitness score.
            </summary>
            <param name="primaryFitness">Primary fitness.</param>
            <param name="auxFitnessScores">Auxiliary fitness scores.</param>
        </member>
        <member name="P:SharpNeat.Evaluation.FitnessInfo.PrimaryFitness">
            <summary>
            Gets the primary fitness score; for most evaluation schemes this is the one and only fitness score.
            </summary>
        </member>
        <member name="P:SharpNeat.Evaluation.FitnessInfo.AuxFitnessScores">
            <summary>
            Gets an array of auxiliary fitness scores.
            </summary>
            <remarks>
            Most problem tasks will yield just a single fitness value via the <see cref="P:SharpNeat.Evaluation.FitnessInfo.PrimaryFitness"/> property,
            and therefore will not use this property.
            This is for problem tasks that produce multiple fitness values per evaluation; in those scenarios there
            is still a single primary fitness provided by <see cref="P:SharpNeat.Evaluation.FitnessInfo.PrimaryFitness"/>, but there are also one or more
            secondary fitness scores that are for reporting purposes only, i.e., they aren't currently used by the
            evolution algorithm.
            </remarks>
        </member>
        <member name="T:SharpNeat.Evaluation.GenomeListEvaluatorFactory">
            <summary>
            Static factory class for creating instances of <see cref="T:SharpNeat.Evaluation.IGenomeListEvaluator`1"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Evaluation.GenomeListEvaluatorFactory.CreateEvaluator``2(SharpNeat.Evaluation.IGenomeDecoder{``0,``1},SharpNeat.Evaluation.IPhenomeEvaluationScheme{``1},System.Int32)">
            <summary>
            Create a new genome list evaluator.
            </summary>
            <typeparam name="TGenome">Genome type.</typeparam>
            <typeparam name="TPhenome">Phenome type.</typeparam>
            <param name="genomeDecoder">Genome decoder, for decoding a genome to a phenome.</param>
            <param name="phenomeEvaluationScheme">Phenome evaluation scheme.</param>
            <param name="degreeOfParallelism">The number of CPU threads to distribute work to.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Evaluation.IGenomeListEvaluator`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.IBlackBoxEvaluationScheme`1">
            <summary>
            Black box evaluation scheme, i.e. an <see cref="T:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1"/> in which the
            phenome type is an <see cref="T:SharpNeat.IBlackBox`1"/>.
            </summary>
            <typeparam name="T">Black box numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Evaluation.IBlackBoxEvaluationScheme`1.InputCount">
            <summary>
            The number of black box inputs expected/required by the black box evaluation scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Evaluation.IBlackBoxEvaluationScheme`1.OutputCount">
            <summary>
            The number of black box inputs expected/required by the black box evaluation scheme.
            </summary>
        </member>
        <member name="T:SharpNeat.Evaluation.IGenomeDecoder`2">
            <summary>
            Represents types that decode genomes into phenomes.
            </summary>
            <typeparam name="TGenome">The genome type to be decoded.</typeparam>
            <typeparam name="TPhenome">The phenome type that is decoded to.</typeparam>
        </member>
        <member name="M:SharpNeat.Evaluation.IGenomeDecoder`2.Decode(`0)">
            <summary>
            Decodes a genome into a phenome.
            </summary>
            <param name="genome">The genome to decode.</param>
            <returns>A phenome if the genome was valid and therefore decoded successfully; otherwise null.</returns>
            <remarks>
            Note that not all genomes have to decode successfully. That is, we support genetic representations
            that may produce non-viable offspring. In such cases this method is allowed to return a null.
            </remarks>
        </member>
        <member name="T:SharpNeat.Evaluation.IGenomeListEvaluator`1">
            <summary>
            Represents an evaluator of lists of genomes.
            </summary>
            <typeparam name="TGenome">Genome type.</typeparam>
        </member>
        <member name="P:SharpNeat.Evaluation.IGenomeListEvaluator`1.IsDeterministic">
            <summary>
            Indicates if the evaluation scheme is deterministic, i.e. will always return the same fitness score for a given genome.
            </summary>
            <remarks>
            An evaluation scheme that has some random/stochastic characteristics may give a different fitness score at each invocation
            for the same genome, such a scheme is non-deterministic.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.IGenomeListEvaluator`1.FitnessComparer">
            <summary>
            Gets a fitness comparer.
            </summary>
            <remarks>
            Typically there is a single fitness score whereby a higher score is better, however if there are multiple fitness scores
            per genome then we need a more general purpose comparer to determine an ordering on FitnessInfo, i.e. to be able to
            determine which is the better FitenssInfo between any two.
            </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.IGenomeListEvaluator`1.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes, assigning fitness info to each.
            </summary>
            <param name="genomeList">The list of genomes to evaluate.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.IGenomeListEvaluator`1.TestForStopCondition(SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Accepts a <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>, which is intended to be from the fittest genome in the population, and returns a boolean
            that indicates if the evolution algorithm can stop, i.e. because the fitness is the best that can be achieved (or good enough).
            </summary>
            <param name="fitnessInfo">The fitness info object to test.</param>
            <returns>Returns true if the fitness is good enough to signal the evolution algorithm to stop.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1">
            <summary>
            Represents an overall phenome evaluation scheme.
            </summary>
            <remarks>
            Provides information related to the evaluation scheme, and a method for creating new evaluator instances.
            </remarks>
            <typeparam name="TPhenome">The phenome type to be evaluated.</typeparam>
        </member>
        <member name="P:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.IsDeterministic">
            <summary>
            Indicates if the evaluation scheme is deterministic, i.e. will always return the same fitness score for a given genome.
            </summary>
            <remarks>
            An evaluation scheme that has some random/stochastic characteristics may give a different fitness score at each invocation
            for the same genome, such a scheme is non-deterministic.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.FitnessComparer">
            <summary>
            Gets a fitness comparer for the scheme.
            </summary>
            <remarks>
            Typically there is a single fitness score and a higher score is considered better/fitter. However, if there are multiple
            fitness values assigned to a genome (e.g. where multiple measures of fitness are in use) then we need a task specific
            comparer to determine the relative fitness between two instances of <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.NullFitness">
            <summary>
            Represents the zero or null fitness for the task. I.e. e.g. for genomes that utterly fail at the task, or genomes that
            fail even to decode (not possible in NEAT).
            </summary>
        </member>
        <member name="P:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.EvaluatorsHaveState">
            <summary>
            Indicates if the evaluators created by <see cref="M:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.CreateEvaluator"/> have state.
            </summary>
            <remarks>
            If an evaluator has no state then it is sufficient to create a single instance and to use that evaluator concurrently on multiple threads.
            If an evaluator has state then concurrent use requires the creation of one evaluator instance per thread.
            </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.CreateEvaluator">
            <summary>
            Create a new evaluator object.
            </summary>
            <returns>A new instance of <see cref="T:SharpNeat.Evaluation.IPhenomeEvaluator`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Evaluation.IPhenomeEvaluationScheme`1.TestForStopCondition(SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Accepts a <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>, which is intended to be from the fittest genome in the population, and returns a boolean
            that indicates if the evolution algorithm can stop, i.e. because the fitness is the best that can be achieved (or good enough).
            </summary>
            <param name="fitnessInfo">The fitness info object to test.</param>
            <returns>Returns true if the fitness is good enough to signal the evolution algorithm to stop.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.IPhenomeEvaluator`1">
            <summary>
            Represents an evaluator of <typeparamref name="TPhenome"/> instances.
            </summary>
            <typeparam name="TPhenome">Phenome input/output signal data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Evaluation.IPhenomeEvaluator`1.Evaluate(`0)">
            <summary>
            Evaluate a single phenome and return its fitness score or scores.
            </summary>
            <param name="phenome">The phenome to evaluate.</param>
            <returns>An instance of <see cref="T:SharpNeat.Evaluation.FitnessInfo"/> that conveys the phenome's fitness scores/data.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.IPhenomeEvaluatorPool`1">
            <summary>
            A pool of phenome evaluators.
            </summary>
            <remarks>
            Used when the phenome evaluators have state, which is expensive to allocate, therefore we wish to
            maintain a pool or re-usable evaluators instead of constructing and discarding a new evaluator for
            each evaluation (or more accurately, each Parallel.For partition).
            </remarks>
            <typeparam name="TPhenome">Phenome type.</typeparam>
        </member>
        <member name="M:SharpNeat.Evaluation.IPhenomeEvaluatorPool`1.GetEvaluator">
            <summary>
            Get an evaluator from the pool.
            </summary>
            <returns>An evaluator instance.</returns>
        </member>
        <member name="M:SharpNeat.Evaluation.IPhenomeEvaluatorPool`1.ReleaseEvaluator(SharpNeat.Evaluation.IPhenomeEvaluator{`0})">
            <summary>
            Releases an evaluator back into the pool.
            </summary>
            <param name="evaluator">The evaluator to release.</param>
        </member>
        <member name="T:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2">
             <summary>
             An implementation of <see cref="T:SharpNeat.Evaluation.IGenomeListEvaluator`1"/> that evaluates genomes in parallel on multiple CPU threads.
             </summary>
             <typeparam name="TGenome">The genome type that is decoded.</typeparam>
             <typeparam name="TPhenome">The phenome type that is decoded to and then evaluated.</typeparam>
             <remarks>
             Genome decoding to a phenome is performed by a <see cref="T:SharpNeat.Evaluation.IGenomeDecoder`2"/>.
             Phenome fitness evaluation is performed by a <see cref="T:SharpNeat.Evaluation.IPhenomeEvaluator`1"/>.
            
             This class is for use with a stateless (and therefore thread safe) phenome evaluator, i.e. one phenome evaluator is created
             and the is used concurrently by multiple threads.
             </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2.#ctor(SharpNeat.Evaluation.IGenomeDecoder{`0,`1},SharpNeat.Evaluation.IPhenomeEvaluationScheme{`1},System.Int32)">
            <summary>
            Construct with the provided genome decoder and phenome evaluator.
            </summary>
            <param name="genomeDecoder">Genome decoder.</param>
            <param name="phenomeEvaluationScheme">Phenome evaluation scheme.</param>
            <param name="degreeOfParallelism">The desired degree of parallelism.</param>
        </member>
        <member name="P:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2.IsDeterministic">
            <summary>
            Indicates if the evaluation scheme is deterministic, i.e. will always return the same fitness score for a given genome.
            </summary>
            <remarks>
            An evaluation scheme that has some random/stochastic characteristics may give a different fitness score at each invocation
            for the same genome, such a scheme is non-deterministic.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2.FitnessComparer">
            <summary>
            The evaluation scheme's fitness comparer.
            </summary>
            <remarks>
            Typically there is a single fitness score and a higher score is considered better/fitter. However, if there are multiple
            fitness values assigned to a genome (e.g. where multiple measures of fitness are in use) then we need a task specific
            comparer to determine the relative fitness between two instances of <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>.
            </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a collection of genomes and assigns fitness info to each.
            </summary>
            <param name="genomeList">The list of genomes to evaluate.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluator`2.TestForStopCondition(SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Accepts a <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>, which is intended to be from the fittest genome in the population, and returns a boolean
            that indicates if the evolution algorithm can stop, i.e. because the fitness is the best that can be achieved (or good enough).
            </summary>
            <param name="fitnessInfo">The fitness info object to test.</param>
            <returns>Returns true if the fitness is good enough to signal the evolution algorithm to stop.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2">
             <summary>
             An implementation of <see cref="T:SharpNeat.Evaluation.IGenomeListEvaluator`1"/> that evaluates genomes in parallel on multiple CPU threads.
             </summary>
             <typeparam name="TGenome">The genome type that is decoded.</typeparam>
             <typeparam name="TPhenome">The phenome type that is decoded to and then evaluated.</typeparam>
             <remarks>
             Genome decoding to a phenome is performed by a <see cref="T:SharpNeat.Evaluation.IGenomeDecoder`2"/>.
             Phenome fitness evaluation is performed by a <see cref="T:SharpNeat.Evaluation.IPhenomeEvaluator`1"/>.
            
             This class is for use with a stateless (and therefore thread safe) phenome evaluator, i.e. one phenome evaluator is created
             and the is used concurrently by multiple threads.
             </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2.#ctor(SharpNeat.Evaluation.IGenomeDecoder{`0,`1},SharpNeat.Evaluation.IPhenomeEvaluationScheme{`1},System.Int32)">
            <summary>
            Construct with the provided genome decoder and phenome evaluator.
            </summary>
            <param name="genomeDecoder">Genome decoder.</param>
            <param name="phenomeEvaluationScheme">Phenome evaluation scheme.</param>
            <param name="degreeOfParallelism">The desired degree of parallelism.</param>
        </member>
        <member name="P:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2.IsDeterministic">
            <summary>
            Indicates if the evaluation scheme is deterministic, i.e. will always return the same fitness score for a given genome.
            </summary>
            <remarks>
            An evaluation scheme that has some random/stochastic characteristics may give a different fitness score at each invocation
            for the same genome, such a scheme is non-deterministic.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2.FitnessComparer">
            <summary>
            The evaluation scheme's fitness comparer.
            </summary>
            <remarks>
            Typically there is a single fitness score and a higher score is considered better/fitter. However, if there are multiple
            fitness values assigned to a genome (e.g. where multiple measures of fitness are in use) then we need a task specific
            comparer to determine the relative fitness between two instances of <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>.
            </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes, assigning fitness info to each.
            </summary>
            <param name="genomeList">The list of genomes to evaluate.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.ParallelGenomeListEvaluatorStateless`2.TestForStopCondition(SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Accepts a <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>, which is intended to be from the fittest genome in the population, and returns a boolean
            that indicates if the evolution algorithm can stop, i.e. because the fitness is the best that can be achieved (or good enough).
            </summary>
            <param name="fitnessInfo">The fitness info object to test.</param>
            <returns>Returns true if the fitness is good enough to signal the evolution algorithm to stop.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.PhenomeEvaluatorStackPool`1">
            <summary>
            A pool of phenome evaluators, in which the pool is implemented with a stack structure with thread synchronised access to the stack.
            </summary>
            <typeparam name="TPhenome">Phenome type.</typeparam>
        </member>
        <member name="M:SharpNeat.Evaluation.PhenomeEvaluatorStackPool`1.#ctor(SharpNeat.Evaluation.IPhenomeEvaluationScheme{`0},System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="phenomeEvaluationScheme">Phenome evaluation scheme.</param>
            <param name="initialPoolSize">Initial pool size.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.PhenomeEvaluatorStackPool`1.GetEvaluator">
            <summary>
            Get an evaluator from the pool.
            </summary>
            <returns>An evaluator instance.</returns>
        </member>
        <member name="M:SharpNeat.Evaluation.PhenomeEvaluatorStackPool`1.ReleaseEvaluator(SharpNeat.Evaluation.IPhenomeEvaluator{`0})">
            <summary>
            Releases an evaluator back into the pool.
            </summary>
            <param name="evaluator">The evaluator to release.</param>
        </member>
        <member name="T:SharpNeat.Evaluation.PrimaryFitnessInfoComparer">
            <summary>
            For comparing the primary fitness of two <see cref="T:SharpNeat.Evaluation.FitnessInfo"/> instances.
            </summary>
        </member>
        <member name="F:SharpNeat.Evaluation.PrimaryFitnessInfoComparer.Singleton">
            <summary>
            Singleton instance.
            </summary>
        </member>
        <member name="M:SharpNeat.Evaluation.PrimaryFitnessInfoComparer.Compare(SharpNeat.Evaluation.FitnessInfo,SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Compares two instances of <see cref="T:SharpNeat.Evaluation.FitnessInfo"/> and returns a value indicating
            whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />.</returns>
        </member>
        <member name="T:SharpNeat.Evaluation.SerialGenomeListEvaluator`2">
             <summary>
             An implementation of <see cref="T:SharpNeat.Evaluation.IGenomeListEvaluator`1"/> that evaluates genomes in series on a single CPU thread.
             </summary>
             <typeparam name="TGenome">The genome type that is decoded.</typeparam>
             <typeparam name="TPhenome">The phenome type that is decoded to and then evaluated.</typeparam>
             <remarks>
             Single threaded evaluation can be useful in various scenarios e.g. when debugging.
            
             Genome decoding is performed by a provided IGenomeDecoder.
             Phenome evaluation is performed by a provided IPhenomeEvaluator.
             </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.SerialGenomeListEvaluator`2.#ctor(SharpNeat.Evaluation.IGenomeDecoder{`0,`1},SharpNeat.Evaluation.IPhenomeEvaluationScheme{`1})">
            <summary>
            Construct with the provided genome decoder and phenome evaluator.
            </summary>
            <param name="genomeDecoder">Genome decoder.</param>
            <param name="phenomeEvaluationScheme">Phenome evaluation scheme.</param>
        </member>
        <member name="P:SharpNeat.Evaluation.SerialGenomeListEvaluator`2.IsDeterministic">
            <summary>
            Indicates if the evaluation scheme is deterministic, i.e. will always return the same fitness score for a given genome.
            </summary>
            <remarks>
            An evaluation scheme that has some random/stochastic characteristics may give a different fitness score at each invocation
            for the same genome. Such a scheme is non-deterministic.
            </remarks>
        </member>
        <member name="P:SharpNeat.Evaluation.SerialGenomeListEvaluator`2.FitnessComparer">
            <summary>
            Gets a fitness comparer.
            </summary>
            <remarks>
            Typically there is a single fitness score whereby a higher score is better, however if there are multiple fitness scores
            per genome then we need a more general purpose comparer to determine an ordering on FitnessInfo(s), i.e. to be able to
            determine which is the better FitenssInfo between any two.
            </remarks>
        </member>
        <member name="M:SharpNeat.Evaluation.SerialGenomeListEvaluator`2.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes, assigning fitness info to each.
            </summary>
            <param name="genomeList">The list of genomes to evaluate.</param>
        </member>
        <member name="M:SharpNeat.Evaluation.SerialGenomeListEvaluator`2.TestForStopCondition(SharpNeat.Evaluation.FitnessInfo)">
            <summary>
            Accepts a <see cref="T:SharpNeat.Evaluation.FitnessInfo"/>, which is intended to be from the fittest genome in the population, and returns a boolean
            that indicates if the evolution algorithm can stop, i.e. because the fitness is the best that can be achieved (or good enough).
            </summary>
            <param name="fitnessInfo">The fitness info object to test.</param>
            <returns>Returns true if the fitness is good enough to signal the evolution algorithm to stop.</returns>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics">
            <summary>
            Conveys statistics related to an <see cref="T:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.Generation">
            <summary>
            The current generation number.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.StopConditionSatisfied">
            <summary>
            Indicates whether some goal fitness has been achieved and that the evolutionary algorithm search should stop.
            This property's value can remain false to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.TotalEvaluationCount">
            <summary>
            Running evaluation count total.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.EvaluationsPerSec">
            <summary>
            Evaluations per second.
            </summary>
            <remarks>
            Based on the difference in <see cref="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.TotalEvaluationCount"/> and <see cref="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.SampleTime"/>,
            between the last two generations.
            </remarks>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics.SampleTime">
            <summary>
            The point in clock time that the statistics were recorded.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm">
            <summary>
            Represents a generational evolution algorithm.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm.Stats">
            <summary>
            Gets the current evolution algorithm statistics.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm.Initialise">
            <summary>
            Initialise the evolutionary algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm.PerformOneGeneration">
            <summary>
            Perform one generation of the evolutionary algorithm.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.IGenome">
            <summary>
            Represents some universal properties of a genome in SharpNEAT.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.IGenome.Id">
            <summary>
            Gets the genome's unique ID. IDs are unique across all genomes created from a single
            IGenomeFactory.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.IGenome.BirthGeneration">
            <summary>
            The generation that a genome was born/created in. Used to track genome age.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.IGenome.FitnessInfo">
            <summary>
            The genome's fitness info.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.IGenome.Complexity">
            <summary>
            Gets a value that is representative of the genome's complexity.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.Population`1">
            <summary>
            A population of genomes.
            </summary>
            <typeparam name="TGenome">Genome type.</typeparam>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Population`1.#ctor(System.Int32)">
            <summary>
            Construct an empty population with the specified target size.
            </summary>
            <param name="targetSize">Population target size.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Population`1.#ctor(System.Int32,System.Collections.Generic.List{`0})">
            <summary>
            Construct a population with the provided genome list and target size.
            </summary>
            <param name="targetSize">Population target size.</param>
            <param name="genomeList">A list of genomes (this allowed to be empty).</param>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Population`1.GenomeList">
            <summary>
            The list of genomes that make up the population.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Population`1.BestGenome">
            <summary>
            Gets the current best genome.
            </summary>
            <remarks>
            Note. If the evolution algorithm has not yet been initialised then this will simply return the genome at index zero in the population.
            </remarks>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Population`1.TargetSize">
            <summary>
            Gets the desired number of genomes in the population.
            </summary>
            <remarks>
            During certain phases of the evolution algorithm the length of <see cref="P:SharpNeat.EvolutionAlgorithm.Population`1.GenomeList"/> will vary and
            therefore it may not match <see cref="P:SharpNeat.EvolutionAlgorithm.Population`1.TargetSize"/> at any given point in time, thus this
            property is the definitive source of the population size.
            </remarks>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Population`1.Stats">
            <summary>
            Population statistics.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Population`1.UpdateStats(System.Collections.Generic.IComparer{SharpNeat.Evaluation.FitnessInfo},Redzen.Random.IRandomSource)">
            <summary>
            Update the population statistics.
            </summary>
            <param name="fitnessComparer">A genome fitness comparer.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Population`1.CreatePopulatonStats">
            <summary>
            Create a new population statistics object.
            </summary>
            <returns>A new instance of <see cref="P:SharpNeat.EvolutionAlgorithm.Population`1.Stats"/>.</returns>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.PopulationStatistics">
            <summary>
            Population statistics.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.BestGenomeIndex">
            <summary>
            Index of the best genome in the population's genome list.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.BestFitness">
            <summary>
            FitnessInfo for the current best genome.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.MeanFitness">
            <summary>
            Mean of the genome primary fitness for the current population.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.BestFitnessHistory">
            <summary>
            A trailing history of best fitness scores at each of the previous N generations.
            This object can also provide a mean over the historical fitness scores, thus providing
            a moving average value.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.BestComplexity">
            <summary>
            Complexity of the current best genome.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.MeanComplexity">
            <summary>
            Mean genome complexity for the current population.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.MaxComplexity">
            <summary>
            Max genome complexity for the current population.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.PopulationStatistics.MeanComplexityHistory">
            <summary>
            A trailing history of mean genome complexity at each of the previous N generations.
            This object can also provide a mean over the historical values, thus providing
            a moving average value.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner">
            <summary>
            Wraps a background worker thread for running an <see cref="T:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm"/>, and provides methods for asynchronous
            control of the worker thread, for starting, stopping, pausing and resuming the evolution algorithm.
            </summary>
        </member>
        <member name="E:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.UpdateEvent">
            <summary>
            Notifies listeners of an update event.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.#ctor(SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm,SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme)">
            <summary>
            Constructs a new instance.
            </summary>
            <param name="ea">The <see cref="T:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm"/> to wrap.</param>
            <param name="updateScheme">Evolution algorithm update event scheme.</param>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.EA">
            <summary>
            The underlying <see cref="T:SharpNeat.EvolutionAlgorithm.IEvolutionAlgorithm"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.UpdateScheme">
            <summary>
            Gets or sets the runner's update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.RunState">
            <summary>
            Gets the current run state of the runner.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.StartOrResume">
            <summary>
            Starts the algorithm running, or resumes a paused algorithm.
            </summary>
            <remarks>
            This method can be called when the runner is in either the Ready or Paused states.
            If the runner is in the Paused state, then the runner is resumed.
            If the runner is already in the Running state, then the method does nothing and returns (and logs a warning).
            For all other states an exception is thrown.
            </remarks>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.RequestPause">
            <summary>
            Requests that the runner pauses, but doesn't wait it to do so.
            </summary>
            <remarks>
            The runner will pause once the worker thread completes execution of the current generation.
            However, this method returns immediately and does not wait for the worker thread to stop.
            </remarks>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.RequestPauseAndWait">
            <summary>
            Request that the runner pauses, and waits it to do so.
            </summary>
            <remarks>
            The runner will pause once the worker thread completes execution of the current generation.
            This method will block and wait for the worker thread to stop before returning.
            </remarks>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.RequestTerminateAndWait">
            <summary>
            Request that the runner terminates, and waits it to do so.
            </summary>
            <remarks>
            The runner will stop once the worker thread completes execution of the current generation.
            This method will block and wait for the worker thread to stop before returning.
            </remarks>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.EvolutionAlgorithmRunner.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.Runner.RunState">
            <summary>
            An enumeration of possible execution states for an IEvolutionAlgorithm.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.RunState.Ready">
            <summary>
            Initialized and ready to start.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.RunState.Running">
            <summary>
            The algorithm is running.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.RunState.Paused">
            <summary>
            The algorithm has been paused, either due to a user request or because a stop condition
            has been met. The algorithm can be restarted if the stop condition is no longer true.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.RunState.Terminated">
            <summary>
            The algorithm thread has terminated. The algorithm cannot be restarted from this state, a new
            algorithm object must be created and started afresh.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.Runner.UpdateMode">
            <summary>
            Evolution algorithm update event modes.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.UpdateMode.None">
            <summary>
            Do not generate any update events.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.UpdateMode.Timespan">
            <summary>
            Generate an update event at regular time intervals.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithm.Runner.UpdateMode.Generational">
            <summary>
            Generate an update event at regular generation intervals. (Every N generations).
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme">
            <summary>
            Evolution algorithm update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.UpdateMode">
            <summary>
            Gets the update scheme's mode.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.Generations">
            <summary>
            Gets the number of generations between updates Applies to the generational update scheme only.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.TimeSpan">
            <summary>
            Gets the timespan between updates. Applies to the timespan update scheme only.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.CreateNoUpdateScheme">
            <summary>
            Create a 'no updates' update scheme.
            </summary>
            <returns>A new instance of <see cref="T:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme"/>.</returns>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.CreateGenerationalUpdateScheme(System.UInt32)">
            <summary>
            Create a generation based update scheme. I.e. the update event will trigger every N generations.
            </summary>
            <param name="generations">The number of generations between update events.</param>
            <returns>A new instance of <see cref="T:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme"/>.</returns>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme.CreateTimeSpanUpdateScheme(System.TimeSpan)">
            <summary>
            Create a clock time based update scheme. I.e. the update event will trigger periodically based on the specified clock time duration/timespan.
            </summary>
            <param name="timespan">The duration between update events.</param>
            <returns>A new instance of <see cref="T:SharpNeat.EvolutionAlgorithm.Runner.UpdateScheme"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.GenomeComparerDescending">
            <summary>
            For comparing genomes based on their fitness.
            The comparison result is reversed compared to the standard rules for an IComparer, therefore using this comparer
            to sort genomes will result in genomes sorted in descending fitness order, i.e. fittest genomes first.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.GenomeComparerDescending.#ctor(System.Collections.Generic.IComparer{SharpNeat.Evaluation.FitnessInfo})">
            <summary>
            Construct with the given <see cref="T:SharpNeat.Evaluation.FitnessInfo"/> comparer.
            </summary>
            <param name="fitnessInfoComparer">A <see cref="T:SharpNeat.Evaluation.FitnessInfo"/> comparer that can be used to compare the relative fitness of any two genomes.</param>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.GenomeComparerDescending.Compare(SharpNeat.EvolutionAlgorithm.IGenome,SharpNeat.EvolutionAlgorithm.IGenome)">
            <summary>
            Compares two genomes, and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first genome to compare.</param>
            <param name="y">The second genome to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />.
            If genome x's fitness is higher then genome y's fitness then returns a positive integer.
            If genome y's fitness is higher then genome x's fitness then returns a negative integer.
            If the two genomes have equal fitness then returns zero.
            </returns>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.CreateSelectionDistributionUtils`1">
            <summary>
            Static utility methods for creating instances of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> that describe genome and species selection probabilities.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.CreateSelectionDistributionUtils`1.CreateSelectionDistributions(SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Numerics.Distributions.Double.DiscreteDistribution@,Redzen.Numerics.Distributions.Double.DiscreteDistribution[]@,System.Int32@)">
            <summary>
            Create instances of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> for sampling species, and for genomes within each given species.
            </summary>
            <param name="speciesArr">Species array.</param>
            <param name="speciesDist">Returns a new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> for sampling from the species array.</param>
            <param name="genomeDistArr">Returns an array of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/>, for sampling from genomes within each species.</param>
            <param name="nonEmptySpeciesCount">Returns the number of species that contain at least one genome.</param>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.CreateSelectionDistributionUtils`1.CreateSpeciesSelectionDistribution(SharpNeat.Neat.Speciation.Species{`0}[],System.Int32@)">
            <summary>
            Create a <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> that describes the probability of each species being selected, for
            cross species reproduction.
            </summary>
            <param name="speciesArr">Species array.</param>
            <param name="nonEmptySpeciesCount">Returns the number of species that contain at least one genome.</param>
            <returns>A new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> for sampling from the species array.</returns>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1">
            <summary>
            The NEAT  evolution algorithm.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.#ctor(SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings,SharpNeat.Evaluation.IGenomeListEvaluator{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Speciation.ISpeciationStrategy{SharpNeat.Neat.Genome.NeatGenome{`0},`0},SharpNeat.Neat.NeatPopulation{`0},SharpNeat.Neat.ComplexityRegulation.IComplexityRegulationStrategy,SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings,SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexualSettings,SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme{`0},Redzen.Random.IRandomSource)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="eaSettings">NEAT evolution algorithm settings.</param>
            <param name="evaluator">An evaluator of lists of genomes.</param>
            <param name="speciationStrategy">Speciation strategy.</param>
            <param name="population">An initial population of genomes.</param>
            <param name="complexityRegulationStrategy">Complexity regulation strategy.</param>
            <param name="reproductionAsexualSettings">Asexual reproduction settings.</param>
            <param name="reproductionSexualSettings">Sexual reproduction settings.</param>
            <param name="weightMutationScheme">Connection weight mutation scheme.</param>
            <param name="rng">Random source (optional).</param>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.Population">
            <summary>
            Gets the <see cref="T:SharpNeat.Neat.NeatPopulation`1"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.Stats">
            <summary>
            Gets the current evolution algorithm statistics.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.ComplexityRegulationMode">
            <summary>
            Gets the current complexity regulation mode.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.Initialise">
            <summary>
            Initialise the evolutionary algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.PerformOneGeneration">
            <summary>
            Perform one generation of the evolution algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.TrimSpeciesBackToElite(System.Boolean@)">
            <summary>
            Loops through species, and for each trims the species genomeList back to the number of elite
            genomes defined for that species.
            </summary>
            <param name="emptySpeciesFlag">Returns true if there is at least one empty species following trimming.</param>
            <remarks>
            The genomes in species.GenomeList are ordered best to worst, thus genomes are removed from the end of the lists.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.RebuildGenomeList">
            <summary>
            Rebuild _genomeList from genomes held within the species.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1.DoGenomeEvaluation(System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{`0}},System.UInt64@)">
            <summary>
            Perform the genome evaluation stage of the evolution algorithm.
            </summary>
            <param name="offspringList">The list of offspring genomes to evaluate.</param>
            <param name="evaluationCount">Returns the number of evaluations that were performed.</param>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings">
            <summary>
            NEAT evolution algorithm settings.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.SpeciesCount">
            <summary>
            The species count.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.ElitismProportion">
            <summary>
            Elitism proportion.
            We sort species genomes by fitness and keep the top N%, the other genomes are
            removed to make way for the offspring.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.SelectionProportion">
            <summary>
            Selection proportion.
            We sort species genomes by fitness and select parent genomes for producing offspring from
            the top N%. Selection is performed prior to elitism being applied, therefore selecting from more
            genomes than will be made elite is possible.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.OffspringAsexualProportion">
            <summary>
            The proportion of offspring to be produced from asexual reproduction (mutation).
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.OffspringSexualProportion">
            <summary>
            The proportion of offspring to be produced from sexual reproduction.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.InterspeciesMatingProportion">
            <summary>
            The proportion of sexual reproductions that will use genomes from different species.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.StatisticsMovingAverageHistoryLength">
            <summary>
            Length of the history buffer used for calculating the moving average for best fitness, mean fitness and mean complexity.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.#ctor(SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings)">
            <summary>
            Copy constructor.
            </summary>
            <param name="copyFrom">The settings object to copy.</param>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.CreateSimplifyingSettings">
            <summary>
            Creates a new settings object based on the current settings object, but modified to be suitable for use when
            the evolution algorithm is in simplifying mode.
            </summary>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings.Validate">
            <summary>
            Validate the settings, and throw an exception if not valid.
            </summary>
            <remarks>
            As a 'simple' collection of properties there is no construction time check that can be performed, therefore this method is supplied to
            allow consumers of a settings object to validate it before using it.
            </remarks>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics">
            <summary>
            NEAT specific evolution algorithm statistics.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics.TotalOffspringCount">
            <summary>
            The total number of offspring genomes created since the evolution algorithm started.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics.TotalOffspringAsexualCount">
            <summary>
            The total number of offspring genomes created through asexual reproduction since the evolution algorithm started.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics.TotalOffspringSexualCount">
            <summary>
            The total number of offspring genomes created through sexual reproduction since the evolution algorithm started.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics.TotalOffspringInterspeciesCount">
            <summary>
            The total number of offspring genomes created through inter-species sexual reproduction since the evolution algorithm started.
            This number is included in <see cref="P:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmStatistics.TotalOffspringSexualCount"/>.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.EvolutionAlgorithm.OffspringBuilder`1">
            <summary>
            For creating new offspring genomes, from one or two parents selected stochastically from a population.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.OffspringBuilder`1.#ctor(SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual{`0},SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexual{`0},System.Double,System.Collections.Generic.IComparer{SharpNeat.Evaluation.FitnessInfo})">
            <summary>
            Construct a new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.OffspringBuilder`1"/>.
            </summary>
            <param name="reproductionAsexual">Asexual reproduction strategy.</param>
            <param name="reproductionSexual">Sexual reproduction strategy.</param>
            <param name="interspeciesMatingProportion">Inter-species mating proportion.</param>
            <param name="fitnessComparer">Fitness comparer.</param>
        </member>
        <member name="M:SharpNeat.Neat.EvolutionAlgorithm.OffspringBuilder`1.CreateOffspring(SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Random.IRandomSource,System.Int32@,System.Int32@,System.Int32@)">
             <summary>
             Creates new offspring from existing parent genomes.
             </summary>
             <param name="speciesArr">An array of species, containing existing elite genomes.</param>
             <param name="rng">Random source.</param>
             <param name="offspringAsexualCount">Returns the number of new offspring created using asexual reproduction.</param>
             <param name="offspringSexualCount">Returns the number of new offspring created using sexual reproduction.</param>
             <param name="offspringInterspeciesCount">Returns the number of new offspring created using sexual
             reproduction between genomes from different species.</param>
             <returns>A new list containing the created offspring genomes.</returns>
             <remarks>
             Each species contains a genome list, which should have been trimmed back to the elite genomes only,
             in order to make space for the new offspring. New offspring are created by application of sexual and
             asexual reproduction on the existing genomes.
            
             The number of offspring genomes to create is determined by <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringAsexualCount"/>
             and <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringSexualCount"/>.
             </remarks>
        </member>
        <member name="T:SharpNeat.Neat.AddedNodeBuffer">
             <summary>
             Stores a history of previously added nodes, keyed by the connection that was split to create the node (i.e.
             the source and target node IDs of the connection).
            
             Used when adding new nodes to check if an identical node (connection split) has been added to a genome elsewhere
             in the population. This allows re-use of the same innovation ID for like nodes.
             </summary>
        </member>
        <member name="M:SharpNeat.Neat.AddedNodeBuffer.#ctor(System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="capacity">Capacity of the history buffer.</param>
        </member>
        <member name="M:SharpNeat.Neat.AddedNodeBuffer.Register(SharpNeat.Graphs.DirectedConnection@,System.Int32)">
            <summary>
            Register a new added node.
            </summary>
            <param name="conn">The connection that was split in order to add the node.</param>
            <param name="addedNodeId">The ID of the added node.</param>
        </member>
        <member name="M:SharpNeat.Neat.AddedNodeBuffer.TryLookup(SharpNeat.Graphs.DirectedConnection@,System.Int32@)">
            <summary>
            Get the node innovation ID from a previous 'add node' mutation based on splitting a connection with the given ID.
            </summary>
            <param name="conn">The connection to look-up.</param>
            <param name="addedNodeId">Returns a node innovation ID, if one was found.</param>
            <returns>True if a node was found, otherwise false.</returns>
        </member>
        <member name="T:SharpNeat.Neat.ComplexityRegulation.AbsoluteComplexityRegulationStrategy">
            <summary>
            A complexity regulation strategy that applies a fixed/absolute complexity ceiling.
            The strategy transitions from complexifying to simplifying when the fixed ceiling is reached.
            Transitioning from simplifying to complexifying occurs when complexity is no longer falling
            *and* complexity is below the ceiling.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.AbsoluteComplexityRegulationStrategy.#ctor(System.Int32,System.Double)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="complexityCeiling">The absolute complexity ceiling.</param>
            <param name="minSimplifcationGenerations">The minimum number of generations we stay within simplification mode.</param>
        </member>
        <member name="P:SharpNeat.Neat.ComplexityRegulation.AbsoluteComplexityRegulationStrategy.CurrentMode">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.AbsoluteComplexityRegulationStrategy.UpdateMode(SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics,SharpNeat.EvolutionAlgorithm.PopulationStatistics)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode">
             <summary>
             Complexity regulation modes.
            
             Represents two variations in the overall search strategy - complexifying and simplifying.
             That is, allowing genomes to complexify, and reducing their complexity to trim away excess
             and/or redundant structure in the population to reinvigorate a search.
            
             For more information see:
             Phased Searching with NEAT: Alternating Between Complexification And Simplification, Colin Green, 2004
             (http://sharpneat.sourceforge.net/phasedsearch.html).
             </summary>
        </member>
        <member name="F:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode.Complexifying">
            <summary>
            Search by allowing genomes to complexify (add new structure).
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode.Simplifying">
            <summary>
            Search by simplifying genomes (removing structure).
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.ComplexityRegulation.IComplexityRegulationStrategy">
             <summary>
             Represents a complexity regulation strategy.
            
             DetermineMode() is called once per generation. A strategy determines the <see cref="T:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode"/>
             that the evolution algorithm search should be in by examining passed in statistics. As such, the simplest valid
             strategy is to just return <see cref="F:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode.Complexifying"/>, which results in no complexity
             regulation taking place.
            
             Complexity regulation is also known as 'Phased Search'. For more information see:
             Phased Searching with NEAT: Alternating Between Complexification And Simplification, Colin Green, 2004
             (http://sharpneat.sourceforge.net/phasedsearch.html).
             </summary>
        </member>
        <member name="P:SharpNeat.Neat.ComplexityRegulation.IComplexityRegulationStrategy.CurrentMode">
            <summary>
            Gets the current complexity regulation mode.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.IComplexityRegulationStrategy.UpdateMode(SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics,SharpNeat.EvolutionAlgorithm.PopulationStatistics)">
            <summary>
            Determine the complexity regulation mode that the evolution algorithm search should be in given the
            provided evolution algorithm statistics object, and set the current mode to that mode.
            </summary>
            <param name="eaStats">Evolution algorithm statistics.</param>
            <param name="popStats">Population statistics.</param>
            <returns>The determined <see cref="T:SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.ComplexityRegulation.NullComplexityRegulationStrategy">
            <summary>
            A complexity regulation strategy that remains fixed in complexifying mode throughout
            the lifetime of the evolution algorithm.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.ComplexityRegulation.NullComplexityRegulationStrategy.CurrentMode">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.NullComplexityRegulationStrategy.UpdateMode(SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics,SharpNeat.EvolutionAlgorithm.PopulationStatistics)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.ComplexityRegulation.RelativeComplexityRegulationStrategy">
             <summary>
             A complexity regulation strategy that applies a moving complexity ceiling that is relative
             to the population mean complexity each at the start of each transition to complexifying mode.
            
             The strategy transitions from complexifying to simplifying when the relative ceiling is reached.
             Transitioning from simplifying to complexifying occurs when complexity is no longer falling
             *and* complexity is below the ceiling.
             </summary>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.RelativeComplexityRegulationStrategy.#ctor(System.Int32,System.Double)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="relativeComplexityCeiling">The relative complexity ceiling.</param>
            <param name="minSimplifcationGenerations">The minimum number of generations we stay within simplification mode.</param>
        </member>
        <member name="P:SharpNeat.Neat.ComplexityRegulation.RelativeComplexityRegulationStrategy.CurrentMode">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.ComplexityRegulation.RelativeComplexityRegulationStrategy.UpdateMode(SharpNeat.EvolutionAlgorithm.EvolutionAlgorithmStatistics,SharpNeat.EvolutionAlgorithm.PopulationStatistics)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.DistanceMetricExtensions">
            <summary>
            Extension methods for <see cref="T:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.DistanceMetricExtensions.CalculateCentroid``1(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{``0},System.Collections.Generic.List{SharpNeat.Neat.Genome.ConnectionGenes{``0}})">
             <summary>
             Calculates the centroid for the given set of points.
             </summary>
             <typeparam name="T">Coordinate component data type.</typeparam>
             <param name="distanceMetric">The distance metric instance.</param>
             <param name="points">The set of points.</param>
             <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/>.</returns>
             <remarks>
             The centroid is a central position within a set of points that minimizes the sum of the squared distance
             between each of those points and the centroid. As such it can also be thought of as being representative
             of the set of points.
            
             The centroid calculation is dependent on the distance metric, hence this method is defined on
             <see cref="T:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1"/>. For some distance metrics the centroid may not be a unique point, in
             those cases one of the possible centroids is returned.
            
             A centroid is used in k-means clustering to define the centre of a cluster.
             </remarks>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.Double.DistanceMetricExtensions">
            <summary>
            Extension method for distance metrics (double precision).
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.DistanceMetricExtensions.FindMedoid(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{System.Double},System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{System.Double}})">
            <summary>
            Find medoid by comparing each coordinate with every other coordinate.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="points">The set of points.</param>
            <returns>The index of the element in <paramref name="points"/> that is the medoid.</returns>
            <remarks>
            The coord with the lowest average distance from all other coords is the most central coord (the medoid).
            This method uses an inefficient N*N comparison of coords to find a medoid. It is provided only as a last
            resort for distance metrics for which no means exist to calculate a centroid.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.DistanceMetricExtensions.CalculateMeanDistanceFromAllOtherPoints(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{System.Double},System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{System.Double}},System.Int32)">
            <summary>
            Calculate the mean distance of the specified point from all of the other points, using the provided
            distance metric.
            </summary>
            <param name="distanceMetric">The distance metric.</param>
            <param name="points">The set of points.</param>
            <param name="idx">The index of the point to measure mean distance to.</param>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.Double.DistanceMetricUtils">
            <summary>
            Static utility methods related to genetic distance metrics.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.DistanceMetricUtils.CalculateEuclideanCentroid(System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{System.Double}})">
             <summary>
             Calculates the L2/Euclidean centroid for the given set of points.
             </summary>
             <param name="points">The set of points.</param>
             <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/>.</returns>
             <remarks>
             The Euclidean centroid is a central position within a set of points that minimizes the sum of the squared
             distance between each of those points and the centroid. As such it can also be thought of as being
             representative of a set of points.
            
             In Euclidean space the centroid is obtained by calculating the componentwise mean over the set of points.
             </remarks>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.Double.EuclideanDistanceMetric">
             <summary>
             Euclidean distance metric.
            
             The Euclidean distance is given by sqrt(sum(delta^2))
             Where [delta] is the absolute position difference in a given dimension (on a given axis).
            
             There may be good reasons to not use this distance metric in NEAT; see this link for some discussion of this:
               https://stats.stackexchange.com/questions/99171/why-is-euclidean-distance-not-a-good-metric-in-high-dimensions .
             </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.EuclideanDistanceMetric.CalcDistance(SharpNeat.Neat.Genome.ConnectionGenes{System.Double},SharpNeat.Neat.Genome.ConnectionGenes{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.EuclideanDistanceMetric.TestDistance(SharpNeat.Neat.Genome.ConnectionGenes{System.Double},SharpNeat.Neat.Genome.ConnectionGenes{System.Double},System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.EuclideanDistanceMetric.CalculateCentroid(System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{System.Double}})">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric">
             <summary>
             Manhattan distance metric.
            
             The Manhattan distance is simply the sum total of all of the distances in each dimension.
             Also known as the taxicab distance, rectilinear distance, L1 distance or L1 norm.
            
             Use the default constructor for classical Manhattan Distance.
             Optionally the constructor can be provided with a two coefficients and a constant that can be used to modify/distort
             distance measures. These are:
            
             matchDistanceCoeff: When comparing two positions in the same dimension the distance between those two position is
             multiplied by this coefficient.
            
             mismatchDistanceCoeff, mismatchDistanceConstant: When comparing two coordinates where one describes a position in a given
             dimension and the other does not then the second coordinate is assumed to be at position zero in that dimension. However,
             the resulting distance is multiplied by this coefficient and mismatchDistanceConstant is added, therefore allowing matches and
             mismatches to be weighted differently, e.g. more emphasis can be placed on mismatches (and therefore network topology).
             If mismatchDistanceCoeff is zero and mismatchDistanceConstant is non-zero then the distance of mismatches is a fixed value.
            
             The two coefficients and constant allow the following schemes:
            
             1) Classical Manhattan distance.
             2) Topology only distance metric (ignore connections weights).
             3) Equivalent of genome distance in Original NEAT (O-NEAT). This is actually a mix of (1) and (2).
             </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric.#ctor">
            <summary>
            Constructs using default weightings for comparisons on matching and mismatching dimensions.
            Classical Manhattan Distance.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs using the provided weightings for comparisons on matching and mismatching dimensions.
            </summary>
            <param name="matchDistanceCoeff">A coefficient to applied to the distance obtained from two coordinates that both
            describe a position in a given dimension.</param>
            <param name="mismatchDistanceCoeff">A coefficient applied to the distance obtained from two coordinates where only one of the coordinates describes
            a position in a given dimension. The other point is taken to be at position zero in that dimension.</param>
            <param name="mismatchDistanceConstant">A constant that is added to the distance where only one of the coordinates describes a position in a given dimension.
            This adds extra emphasis to distance when comparing coordinates that exist in different dimensions.</param>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric.CalcDistance(SharpNeat.Neat.Genome.ConnectionGenes{System.Double},SharpNeat.Neat.Genome.ConnectionGenes{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric.TestDistance(SharpNeat.Neat.Genome.ConnectionGenes{System.Double},SharpNeat.Neat.Genome.ConnectionGenes{System.Double},System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.Double.ManhattanDistanceMetric.CalculateCentroid(System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{System.Double}})">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1">
            <summary>
            Represents a metric for measuring the distance between two genome positions in an encoding space, and thus,
            in principle, the compatibility of the two genomes with respect to the probability of creating fit offspring.
            </summary>
            <typeparam name="T">Coordinate component data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1.CalcDistance(SharpNeat.Neat.Genome.ConnectionGenes{`0},SharpNeat.Neat.Genome.ConnectionGenes{`0})">
            <summary>
            Calculates the distance between two positions.
            </summary>
            <param name="p1">Position one.</param>
            <param name="p2">Position two.</param>
            <returns>The distance between <paramref name="p1"/> and <paramref name="p2"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1.TestDistance(SharpNeat.Neat.Genome.ConnectionGenes{`0},SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Double)">
            <summary>
            Tests if the distance between two positions is less than some threshold.
            </summary>
            <param name="p1">Position one.</param>
            <param name="p2">Position two.</param>
            <param name="threshold">Distance threshold.</param>
            <returns>
            True if the distance between <paramref name="p1"/> and <paramref name="p2"/> is less than
            <paramref name="threshold"/>.
            </returns>
        </member>
        <member name="M:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1.CalculateCentroid(System.ReadOnlySpan{SharpNeat.Neat.Genome.ConnectionGenes{`0}})">
             <summary>
             Calculates the centroid for the given set of points.
             </summary>
             <param name="points">The set of points.</param>
             <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/>.</returns>
             <remarks>
             The centroid is a central position within a set of points that minimizes the sum of the squared distance
             between each of those points and the centroid. As such it can also be thought of as being representative
             of the set of points.
            
             The centroid calculation is dependent on the distance metric, hence this method is defined on
             <see cref="T:SharpNeat.Neat.DistanceMetrics.IDistanceMetric`1"/>. For some distance metrics the centroid may not be a unique point, in
             those cases one of the possible centroids is returned.
            
             A centroid is used in k-means clustering to define the centre of a cluster.
             </remarks>
        </member>
        <member name="T:SharpNeat.Neat.Genome.ConnectionGenes`1">
            <summary>
            Connections genes represented as a structure of arrays (see https://en.wikipedia.org/wiki/AOS_and_SOA).
            Element i of each array represents a value relating to the 'i'th gene.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="F:SharpNeat.Neat.Genome.ConnectionGenes`1._connArr">
            <summary>
            Array of directed connections; this describes the network structure.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Genome.ConnectionGenes`1._weightArr">
            <summary>
            Array of connection weights.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.ConnectionGenes`1.#ctor(System.Int32)">
            <summary>
            Construct uninitialised arrays with the given length.
            </summary>
            <param name="length">Number of connection genes to allocate space for.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.ConnectionGenes`1.#ctor(SharpNeat.Graphs.DirectedConnection[],`0[])">
            <summary>
            Construct with the pre-built arrays.
            </summary>
            <param name="connArr">Array of directed connections; this described the network structure.</param>
            <param name="weightArr">Array of connection weights.</param>
        </member>
        <member name="P:SharpNeat.Neat.Genome.ConnectionGenes`1.Length">
            <summary>
            Gets the number of connection genes.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.ConnectionGenes`1.Item(System.Int32)">
            <summary>
            Connection gene indexer.
            </summary>
            <param name="idx">Index of the gene to get or set.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.ConnectionGenes`1.Sort">
            <summary>
            Sort the connection genes by sourceID then targetID.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Genome.ConnectionGenesUtils">
            <summary>
            Static utility methods related to connection genes.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.ConnectionGenesUtils.CreateHiddenNodeIdArray(SharpNeat.Graphs.DirectedConnection[],System.Int32,System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Create a sorted array of hidden node IDs.
            </summary>
            <param name="connArr">An array of directed connections from which to extract/determine the hidden node IDs.</param>
            <param name="inputOutputCount">The number of input and output nodes. Hidden node IDs start after these nodes.</param>
            <param name="workingIdSet">A working/reusable hashset. This is cleared and re-populated with the hidden nodes IDs before returning.</param>
            <returns>A new array that contains all of the hidden node IDs, sorted in ascending order.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.ConnectionGenesUtils.ValidateHiddenNodeIds(System.Int32[],SharpNeat.Graphs.DirectedConnection[],System.Int32)">
            <summary>
            Validation tests on an array of hidden node IDs and an associated array of connections.
            </summary>
            <param name="hiddenNodeIdArr">Array of hidden node IDs.</param>
            <param name="connArr">Array of connections.</param>
            <param name="inputOutputCount">The total number of input and output nodes.</param>
            <returns>true if the provided data is valid; otherwise false.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderAcyclic">
            <summary>
            For decoding instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to <see cref="T:SharpNeat.IBlackBox`1"/>, specifically
            acyclic neural network instances implemented by <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclic"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderAcyclic.Decode(SharpNeat.Neat.Genome.NeatGenome{System.Double})">
            <summary>
            Decodes a NEAT genome into a working neural network.
            </summary>
            <param name="genome">The genome to decode.</param>
            <returns>An <see cref="T:SharpNeat.IBlackBox`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderCyclic">
            <summary>
            For decoding instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to <see cref="T:SharpNeat.IBlackBox`1"/>, specifically
            cyclic neural network instances implemented by either <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetCyclic"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderCyclic.Decode(SharpNeat.Neat.Genome.NeatGenome{System.Double})">
            <summary>
            Decodes a NEAT genome into a working neural network.
            </summary>
            <param name="genome">The genome to decode.</param>
            <returns>An <see cref="T:SharpNeat.IBlackBox`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderFactory">
            <summary>
            Static factory methods for creating new instances of <see cref="T:SharpNeat.Evaluation.IGenomeDecoder`2"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.Double.NeatGenomeDecoderFactory.CreateGenomeDecoder(System.Boolean,System.Boolean)">
            <summary>
            Create a genome decoder that decodes a <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to an appropriate neural network
            implementation.
            </summary>
            <param name="isAcyclic">Decode to an acyclic neural network.</param>
            <param name="enableHardwareAcceleration">Enable use of hardware accelerated black box (i.e neural network)
            implementations.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Evaluation.IGenomeDecoder`2"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.Double.Vectorized.NeatGenomeDecoderAcyclic">
            <summary>
            For decoding instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to <see cref="T:SharpNeat.IBlackBox`1"/>, specifically
            acyclic neural network instances implemented by <see cref="T:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.Double.Vectorized.NeatGenomeDecoderAcyclic.Decode(SharpNeat.Neat.Genome.NeatGenome{System.Double})">
            <summary>
            Decodes a NEAT genome into a working neural network.
            </summary>
            <param name="genome">The genome to decode.</param>
            <returns>An <see cref="T:SharpNeat.IBlackBox`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.Double.Vectorized.NeatGenomeDecoderCyclic">
            <summary>
            For decoding instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to <see cref="T:SharpNeat.IBlackBox`1"/>, specifically
            cyclic neural network instances implemented by <see cref="T:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.Double.Vectorized.NeatGenomeDecoderCyclic.Decode(SharpNeat.Neat.Genome.NeatGenome{System.Double})">
            <summary>
            Decodes a NEAT genome into a working neural network.
            </summary>
            <param name="genome">The genome to decode.</param>
            <returns>An <see cref="T:SharpNeat.IBlackBox`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.INeatGenomeBuilder`1">
            <summary>
            For creating new instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.INeatGenomeBuilder`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0})">
            <summary>
            Create a NeatGenome with the given meta data and connection genes.
            </summary>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Birth generation.</param>
            <param name="connGenes">Connection genes.</param>
            <returns>A new NeatGenome instance.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.INeatGenomeBuilder`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[])">
            <summary>
            Create a NeatGenome with the given meta data, connection genes and supplementary data.
            </summary>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Birth generation.</param>
            <param name="connGenes">Connection genes.</param>
            <param name="hiddenNodeIdArr">An array of the hidden node IDs in the genome, in ascending order.</param>
            <returns>A new NeatGenome instance.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.INeatGenomeBuilder`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap)">
            <summary>
            Create a NeatGenome with the given meta data, connection genes and supplementary data.
            </summary>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Birth generation.</param>
            <param name="connGenes">Connection genes.</param>
            <param name="hiddenNodeIdArr">An array of the hidden node IDs in the genome, in ascending order.</param>
            <param name="nodeIndexByIdMap">Provides a mapping from node ID to node index.</param>
            <returns>A new NeatGenome instance.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.INeatGenomeBuilder`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.DirectedGraph,System.Int32[])">
            <summary>
            Create a NeatGenome with the given meta data, connection genes and supplementary data.
            </summary>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Birth generation.</param>
            <param name="connGenes">Connection genes.</param>
            <param name="hiddenNodeIdArr">An array of the hidden node IDs in the genome, in ascending order.</param>
            <param name="nodeIndexByIdMap">Provides a mapping from node ID to node index.</param>
            <param name="digraph">A DirectedGraph that mirrors the structure described by the connection genes.</param>
            <param name="connectionIndexMap">Mapping from genome connection indexes (in NeatGenome.ConnectionGenes) to reordered connections, based on depth based
            node index allocations.</param>
            <returns>A new NeatGenome instance.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.IO.NeatGenomeConverter">
            <summary>
            Static methods for converting between <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> and <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeConverter.ToNetFileModel``1(SharpNeat.Neat.Genome.NeatGenome{``0})">
            <summary>
            Convert a <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> into a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance, suitable for saving to
            file.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="genome">The genome to convert.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeConverter.ToNeatGenome``1(SharpNeat.IO.Models.NetFileModel,SharpNeat.Neat.Genome.MetaNeatGenome{``0},System.Int32,System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance into a <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> instance.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="metaNeatGenome">A <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/> instance; required to construct a new
            <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</param>
            <param name="genomeId">The ID to assign to the created genome instance.</param>
            <param name="throwIfActivationFnMismatch">If true then an exception is thrown if the activation function
            defined on <paramref name="model"/> does not match the one defined on <paramref name="metaNeatGenome"/>.
            If false, and there is a mismatch, then the activation defined on the <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/> is used.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.IO.NeatGenomeLoader">
            <summary>
            For loading/deserializing instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> from file, stream, etc.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeLoader.Load``1(System.String,SharpNeat.Neat.Genome.MetaNeatGenome{``0},System.Int32)">
            <summary>
            Load a genome from the specified file.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="path">The name and path of the file to load.</param>
            <param name="metaNeatGenome">A <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/> instance; required to construct a new
            <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</param>
            <param name="genomeId">The ID to assign to the new genome.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeLoader.Load``1(System.IO.Stream,SharpNeat.Neat.Genome.MetaNeatGenome{``0},System.Int32)">
            <summary>
            Load a genome from the provided stream.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="stream">The stream to load from.</param>
            <param name="metaNeatGenome">A <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/> instance; required to construct a new
            <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</param>
            <param name="genomeId">The ID to assign to the new genome.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.IO.NeatGenomeSaver">
            <summary>
            For saving/serializing instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> to file, stream, etc.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeSaver.Save``1(SharpNeat.Neat.Genome.NeatGenome{``0},System.String)">
            <summary>
            Save a genome to the specified file.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="genome">The genome to save.</param>
            <param name="path">The path of the file to save to.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatGenomeSaver.Save``1(SharpNeat.Neat.Genome.NeatGenome{``0},System.IO.Stream)">
            <summary>
            Save a genome to the given stream.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="genome">The genome to save.</param>
            <param name="stream">The stream to save the genome to.</param>
            <remarks>This method does not close the Stream.</remarks>
        </member>
        <member name="T:SharpNeat.Neat.Genome.IO.NeatPopulationLoader`1">
            <summary>
            For loading/deserializing a population of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> instances from the local filesystem.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatPopulationLoader`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0})">
            <summary>
            Construct with the provided <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.
            </summary>
            <param name="metaNeatGenome">Neat genome metadata object.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatPopulationLoader`1.LoadFromFolder(System.String)">
            <summary>
            Load a population from a folder containing one or more genome files (with a .net file extension).
            </summary>
            <param name="path">Path to the folder to load genomes from.</param>
            <returns>A list of the loaded genomes.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatPopulationLoader`1.LoadFromZipArchive(System.String)">
            <summary>
            Load a population from a zip archive file containing one or more genome file entries (with a .net file extension).
            </summary>
            <param name="path">Path to the zip file to load.</param>
            <returns>A list of the loaded genomes.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.IO.NeatPopulationSaver">
            <summary>
            For saving/serializing a population of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/> instances to the local filesystem.
            </summary>
            <remarks>
            A population is a collection of genomes. The genomes are each serialized individually, as when saving a single genome.
            The genome files are then either created in a new folder that contains all genomes for the population, or in a single
            zip archive file.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatPopulationSaver.SaveToFolder``1(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{``0}},System.String,System.String)">
            <summary>
            Save the given population of genomes to the specified path on the local filesystem.
            </summary>
            <param name="genomeList">The population of genomes to save.</param>
            <param name="parentPath">Path to an existing folder to create the new population folder.</param>
            <param name="name">The name to assign to the population folder.</param>
            <typeparam name="T">Connection weight data type.</typeparam>
            <remarks>
            A population is a collection of genomes. The genomes each serialized individually as when saving a single genome.
            The genome files are then either created in a new folder that contains all genomes for the population, or in a single
            zip archive file.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Genome.IO.NeatPopulationSaver.SaveToZipArchive``1(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{``0}},System.String,System.IO.Compression.CompressionLevel)">
            <summary>
            Save the given population of genomes to a single zip archive file.
            </summary>
            <param name="genomeList">The population of genomes to save.</param>
            <param name="filepath">The name of the zip archive (without the .zip extension, which will be appended by default).</param>
            <param name="compressionLevel">ZIP archive compression level.</param>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="T:SharpNeat.Neat.Genome.MetaNeatGenome`1">
            <summary>
            NeatGenome metadata.
            Genome related values/settings that are consistent across all genomes for the lifetime of an evolutionary algorithm run.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.InputNodeCount">
            <summary>
            Input node count.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.OutputNodeCount">
            <summary>
            Output node count.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic">
            <summary>
            Indicates if the genomes that are evolved are acyclic, i.e. they should have no recurrent/cyclic
            connection paths.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.CyclesPerActivation">
            <summary>
            For cyclic neural networks (i.e. if <see cref="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic"/> = false) this defines how many timesteps to
            run the neural net per call to Activate().
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.ActivationFn">
            <summary>
            The neuron activation function to use in evolved networks. NEAT uses the same activation
            function at each node.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.ConnectionWeightScale">
            <summary>
            Maximum connection weight scale/magnitude.
            E.g. a value of 5 defines a weight range of -5 to 5.
            The weight range is strictly enforced, e.g. when creating new connections and mutating existing ones.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.InputOutputNodeCount">
            <summary>
            The total number of input and output nodes.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.MetaNeatGenome`1.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32,SharpNeat.NeuralNets.IActivationFunction{`0},System.Double)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="inputNodeCount">Input node count.</param>
            <param name="outputNodeCount">Output node count.</param>
            <param name="isAcyclic">Indicates if the genomes that are evolved are acyclic, i.e. they should have no
            recurrent/cyclic connection paths.</param>
            <param name="cyclesPerActivation">For cyclic neural networks (i.e. if <see cref="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic"/> = false)
            this defines how many timesteps to run the neural net per call to Activate().</param>
            <param name="activationFn">The neuron activation function to use in evolved networks. NEAT uses the same
            activation function at each node.</param>
            <param name="connectionWeightScale">Maximum connection weight scale/magnitude.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.MetaNeatGenome`1.CreateAcyclic(System.Int32,System.Int32,SharpNeat.NeuralNets.IActivationFunction{`0},System.Double)">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>, with <see cref="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic"/> set to true, i.e.,
            for evolving acyclic neural networks.
            </summary>
            <param name="inputNodeCount">Input node count.</param>
            <param name="outputNodeCount">Output node count.</param>
            <param name="activationFn">The neuron activation function to use in evolved networks. NEAT uses the same
            activation function at each node.</param>
            <param name="connectionWeightScale">Maximum connection weight scale/magnitude.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.MetaNeatGenome`1.CreateCyclic(System.Int32,System.Int32,System.Int32,SharpNeat.NeuralNets.IActivationFunction{`0},System.Double)">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>, with <see cref="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic"/> set to false, i.e.,
            for evolving cyclic neural networks.
            </summary>
            <param name="inputNodeCount">Input node count.</param>
            <param name="outputNodeCount">Output node count.</param>
            <param name="cyclesPerActivation">For cyclic neural networks (i.e. if <see cref="P:SharpNeat.Neat.Genome.MetaNeatGenome`1.IsAcyclic"/> = false)
            this defines how many timesteps to run the neural net per call to Activate().</param>
            <param name="activationFn">The neuron activation function to use in evolved networks. NEAT uses the same
            activation function at each node.</param>
            <param name="connectionWeightScale">Maximum connection weight scale/magnitude.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenome`1">
            <summary>
            Represents a NEAT genome, i.e the genetic representation of a neural network.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.Id">
            <summary>
            Genome ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.BirthGeneration">
            <summary>
            Genome birth generation.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.FitnessInfo">
            <summary>
            Genome fitness info.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.Complexity">
            <summary>
            Gets a value that is representative of the genome's complexity.
            </summary>
            <remarks>
            For a NEAT genome we take the number of connections as representative of genome complexity.
            </remarks>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.MetaNeatGenome">
            <summary>
            Genome metadata.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.ConnectionGenes">
            <summary>
            Connection genes data structure.
            These define both the neural network structure/topology and the connection weights.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.HiddenNodeIdArray">
            <summary>
            An array of hidden node IDs, sorted to allow efficient lookup of an ID with a binary search.
            Input and output node IDs are not included because these are allocated fixed IDs starting from zero
            and are therefore always known.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.NodeIndexByIdMap">
            <summary>
            Mapping function for obtaining a node index for a given node ID.
            </summary>
            <remarks>
            Node indexes have a range of 0 to N-1 (for N nodes), i.e. the indexes are zero based and contiguous; as opposed to node IDs, which are not contiguous.
            </remarks>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.DirectedGraph">
             <summary>
             The directed graph that the current genome represents.
             </summary>
             <remarks>
             This digraph mirrors the graph described by <see cref="P:SharpNeat.Neat.Genome.NeatGenome`1.ConnectionGenes"/>; this object represents the
             graph structure only, not the weights, and is therefore re-used when spawning genomes with the same structure
             (i.e. a child that is the result of connection weight mutations only).
             The DirectedGraph class provides an efficient means of working with graphs and is therefore made available
             on this class to provide improved performance for:
              * Decoding to a neural net object.
              * Finding new connections on acyclic graphs, i.e. detecting if a random new connection would form a cycle.
            
             Note. When MetaNeatGenome.IsAcyclic is true then the object stored here will be of the subtype <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/> .
             </remarks>
        </member>
        <member name="P:SharpNeat.Neat.Genome.NeatGenome`1.ConnectionIndexMap">
             <summary>
             Cached info related to acyclic digraphs only.
            
             Represents a mapping between genome connection indexes (in NeatGenome.ConnectionGenes), to reordered connections
             based on depth based node index allocations (as utilised in DirectedGraphAcyclic).
            
             This allows for mapping of weights from NeatGenome.ConnectionGenes to the re-ordered weight array used by the neural
             net implementation (AcyclicNeuralNet).
            
             The mapping is in the form of an array of indexes into NeatGenome.ConnectionGenes, i.e. the position in the index
             is the 'new' index (the digraph index), and the value stored at that position is the 'old' index (the genome
             connection index).
             </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenome`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.DirectedGraph,System.Int32[])">
            <summary>
            Constructs with the provided ID, birth generation and gene arrays.
            </summary>
            <param name="metaNeatGenome">Meta NEAT genome.</param>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Genome birth generation.</param>
            <param name="connGenes">Genome connection genes.</param>
            <param name="hiddenNodeIdArr">Array of hidden node IDs.</param>
            <param name="nodeIndexByIdMap">A mapping from node IDs to node indexes.</param>
            <param name="digraph">A directed graph that represents the neural network structure.</param>
            <param name="connectionIndexMap">A mapping between genome connection indexes (in <paramref name="connGenes"/>),
            to reordered connections based on depth based node index allocations (optional, acyclic genomes only).</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenome`1.ContainsHiddenNode(System.Int32)">
            <summary>
            Tests if the genome contains a connection that refers to the given hidden node ID.
            </summary>
            <param name="id">Node ID.</param>
            <returns>True if the genome contains a hidden node with the specified ID; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenome`1.GetDigraphWeightArray">
            <summary>
            Gets an array of connection weights, ordered to match the connections of <see cref="P:SharpNeat.Neat.Genome.NeatGenome`1.DirectedGraph"/>.
            </summary>
            <returns>An array of connection weights.</returns>
            <remarks>
            For cyclic genomes this is simply the genome's weight array, but for acyclic genomes the digraph and genome
            represent connections in a different order, thus for acyclic genomes/digraphs this method will return a new
            array with the weights in the digraph order.
            </remarks>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenomeAssertions`1">
            <summary>
            Static methods for validating/verifying the data associated with a NEAT genome.
            Principally for use in debug builds and debugging sessions.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeAssertions`1.AssertIsValid(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.DirectedGraph,System.Int32[])">
            <summary>
            Validate/verify the data associated with a NEAT genome, applying a series of debug asserts.
            </summary>
            <param name="metaNeatGenome">Genome metadata.</param>
            <param name="id">Genome ID.</param>
            <param name="birthGeneration">Genome birth generation.</param>
            <param name="connGenes">Connection genes data structure.</param>
            <param name="hiddenNodeIdArr">An array of the genome's hidden node IDs.</param>
            <param name="nodeIndexByIdMap">Mapping function for obtaining a node index for a given node ID.</param>
            <param name="digraph">The directed graph that the current genome represents.</param>
            <param name="connectionIndexMap">A set of connection index mappings.</param>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1">
            <summary>
            For building instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>. For use when evolving acyclic graphs only.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Boolean)">
            <summary>
            Construct with the given NEAT genome metadata.
            </summary>
            <param name="metaNeatGenome">NEAT genome metadata.</param>
            <param name="validateAcyclic">Enable acyclic graph validation.</param>
            <remarks>
            If the caller can guarantee that calls to Create() will provide acyclic graphs only, then
            <paramref name="validateAcyclic"/> can be set to false to avoid the cost of the cyclic graph check (which is relatively expensive to perform).
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderAcyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.DirectedGraph,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1">
            <summary>
            For building instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>. For use when evolving cyclic graphs only.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0})">
            <summary>
            Construct with the given NEAT genome metadata.
            </summary>
            <param name="metaNeatGenome">NEAT genome metadata.</param>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderCyclic`1.Create(System.Int32,System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32[],SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.DirectedGraph,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenomeBuilderFactory`1">
            <summary>
            Static factory class for creating instances of <see cref="T:SharpNeat.Neat.Genome.INeatGenomeBuilder`1"/>.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderFactory`1.Create(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Boolean)">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.Genome.INeatGenomeBuilder`1"/>.
            </summary>
            <param name="metaNeatGenome">Neat genome metadata.</param>
            <param name="validateAcyclic">Enable acyclic graph validation.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.INeatGenomeBuilder`1"/>.</returns>
            <remarks>
            If the caller can guarantee that calls to Create() will provide acyclic graphs only when metaNeatGenome.IsAcyclic is true, then
            <paramref name="validateAcyclic"/> can be set to false to avoid the cost of the cyclic graph check (which is relatively expensive to perform).
            </remarks>
        </member>
        <member name="T:SharpNeat.Neat.Genome.NeatGenomeBuilderUtils">
            <summary>
            Static utility methods related to the building of new instances of <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Genome.NeatGenomeBuilderUtils.CreateDirectedGraph``1(SharpNeat.Neat.Genome.MetaNeatGenome{``0},SharpNeat.Neat.Genome.ConnectionGenes{``0},SharpNeat.Graphs.INodeIdMap)">
            <summary>
            Create a digraph from the a set of connection genes.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="metaNeatGenome">Genome metadata.</param>
            <param name="connGenes">Connection genes.</param>
            <param name="nodeIndexByIdMap">A mapping from node IDs to node indexes.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.DirectedGraph"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.NeatPopulation`1">
            <summary>
            A NEAT population.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.MetaNeatGenome">
            <summary>
            NeatGenome metadata.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.GenomeBuilder">
            <summary>
            NeatGenome builder.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.GenomeIdSeq">
            <summary>
            Genome ID sequence; for obtaining new genome IDs.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.InnovationIdSeq">
            <summary>
            Innovation ID sequence; for obtaining new innovation IDs.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.AddedNodeBuffer">
            <summary>
            A history buffer of added nodes.
            Used when adding new nodes to check if an identical node has been added to a genome elsewhere in the population.
            This allows re-use of the same innovation ID for like nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.SpeciesArray">
            <summary>
            Species array.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulation`1.NeatPopulationStats">
            <summary>
            NeatPopulation statistics.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},System.Int32,System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{`0}})">
            <summary>
            Construct a new population with the provided genomes.
            </summary>
            <param name="metaNeatGenome">NeatGenome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="targetSize">Population target size.</param>
            <param name="genomeList">A list of genomes that will make up the population.</param>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},System.Int32,System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{`0}},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Construct a new population with the provided genomes and accompanying objects.
            </summary>
            <param name="metaNeatGenome">NeatGenome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="targetSize">Population target size.</param>
            <param name="genomeList">A list of genomes that will make up the population.</param>
            <param name="genomeIdSeq">Genome ID sequence.</param>
            <param name="innovationIdSeq">Innovation ID sequence.</param>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},System.Int32,System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{`0}},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,System.Int32)">
            <summary>
            Construct a new population with the provided genomes and accompanying objects.
            </summary>
            <param name="metaNeatGenome">NeatGenome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="targetSize">Population target size.</param>
            <param name="genomeList">A list of genomes that will make up the population.</param>
            <param name="genomeIdSeq">Genome ID sequence.</param>
            <param name="innovationIdSeq">Innovation ID sequence.</param>
            <param name="addedNodeHistoryBufferSize">The size to allocate for the added node history buffer.</param>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.InitialiseSpecies(SharpNeat.Neat.Speciation.ISpeciationStrategy{SharpNeat.Neat.Genome.NeatGenome{`0},`0},System.Int32,System.Collections.Generic.IComparer{SharpNeat.Neat.Genome.NeatGenome{`0}},Redzen.Random.IRandomSource)">
            <summary>
            Initialise (or re-initialise) the population species.
            </summary>
            <param name="speciationStrategy">The speciation strategy to use.</param>
            <param name="speciesCount">The required number of species.</param>
            <param name="genomeComparerDescending">A genome comparer for sorting by fitness in descending order.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.UpdateStats(System.Collections.Generic.IComparer{SharpNeat.Evaluation.FitnessInfo},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.ClearAllSpecies">
            <summary>
            Clear the genome list of all species.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.ContainsEmptySpecies">
            <summary>
            Returns true if there is at least one empty species.
            </summary>
            <returns>True if there is at least one empty species; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulation`1.CreatePopulatonStats">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.NeatPopulationFactory`1">
            <summary>
            Factory class for creating new instances of <see cref="T:SharpNeat.Neat.NeatPopulationFactory`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationFactory`1.CreateGenomeList(System.Int32)">
            <summary>
            Creates a list of randomly initialised genomes.
            </summary>
            <param name="count">The number of genomes to create.</param>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationFactory`1.CreateGenome">
            <summary>
            Creates a single randomly initialised genome.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationFactory`1.CreatePopulation(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Double,System.Int32,Redzen.Random.IRandomSource)">
            <summary>
            Create a new <see cref="T:SharpNeat.Neat.NeatPopulation`1"/> with randomly initialised genomes.
            Genomes are randomly initialised by giving each a random subset of all possible connections between the
            input and output layer.
            </summary>
            <param name="metaNeatGenome">Genome metadata, conveys e.g. the number of input and output nodes that each
            genome should have.</param>
            <param name="connectionsProportion">The proportion of possible connections between the input and output
            layers, to create in each new genome.</param>
            <param name="popSize">Population size.</param>
            <param name="rng">Random source (optional).</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.NeatPopulation`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationFactory`1.CreatePopulation(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Int32,SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings,SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme{`0},Redzen.Random.IRandomSource)">
            <summary>
            Create a new <see cref="T:SharpNeat.Neat.NeatPopulation`1"/> based on a single seed genome.
            </summary>
            <param name="metaNeatGenome">Genome metadata, conveys e.g. the number of input and output nodes that each
            genome should have.</param>
            <param name="popSize">Population size.</param>
            <param name="seedGenome">The seed genome.</param>
            <param name="reproductionAsexualSettings">Asexual reproduction settings.</param>
            <param name="weightMutationScheme">Connection weight mutation scheme.</param>
            <param name="rng">Random source (optional).</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.NeatPopulation`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationFactory`1.CreatePopulation(SharpNeat.Neat.Genome.MetaNeatGenome{`0},System.Int32,System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings,SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme{`0},Redzen.Random.IRandomSource)">
            <summary>
            Create a new <see cref="T:SharpNeat.Neat.NeatPopulation`1"/> based on one of more seed genomes.
            </summary>
            <param name="metaNeatGenome">Genome metadata, conveys e.g. the number of input and output nodes that each
            genome should have.</param>
            <param name="popSize">Population size.</param>
            <param name="seedGenomes">The seed genomes.</param>
            <param name="reproductionAsexualSettings">Asexual reproduction settings.</param>
            <param name="weightMutationScheme">Connection weight mutation scheme.</param>
            <param name="rng">Random source (optional).</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.NeatPopulation`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.NeatPopulationStatistics">
            <summary>
            NeatPopulation statistics.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulationStatistics.BestGenomeSpeciesIdx">
            <summary>
            Index of the species that the best genome is within.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulationStatistics.SumSpeciesMeanFitness">
            <summary>
            Sum of species fitness means.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.NeatPopulationStatistics.AverageSpeciesBestFitness">
            <summary>
            The average (mean) fitness calculated over all species' best/champ genomes.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.NeatPopulationUtils">
            <summary>
            Static utility methods related to <see cref="T:SharpNeat.Neat.NeatPopulation`1"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationUtils.ValidateIdSequences``1(System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{``0}},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Tests if the ID sequence objects represent an ID higher than any existing ID used by the genomes.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="genomeList">Genome list.</param>
            <param name="genomeIdSeq">The next genome ID.</param>
            <param name="innovationIdSeq">The next innovation ID.</param>
            <returns>
            True if all genomes in <paramref name="genomeList"/> have an ID that is less than the next genome ID,
            and have connection genes with IDs less than the next innovation ID; otherwise false.
            </returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatPopulationUtils.GetMaxObservedIds``1(System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{``0}},System.Int32@,System.Int32@)">
            <summary>
            Get the maximum genome ID and innovation ID used in the provided genomes.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="genomeList">Genome list.</param>
            <param name="maxGenomeId">Returns the maximum genome ID in the genomes of <paramref name="genomeList"/>.</param>
            <param name="maxInnovationId">Returns the maximum innovation ID in the genomes of <paramref name="genomeList"/>.</param>
        </member>
        <member name="T:SharpNeat.Neat.NeatUtils">
            <summary>
            Utility methods for creating and correctly 'wiring up' instances of NeatEvolutionAlgorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.NeatUtils.CreateNeatEvolutionAlgorithm(SharpNeat.Experiments.INeatExperiment{System.Double},SharpNeat.Neat.NeatPopulation{System.Double})">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1"/> for the given neat experiment, and neat
            population.
            </summary>
            <param name="neatExperiment">A neat experiment instance; this conveys everything required to create a new
            evolution algorithm instance that is ready to be run.</param>
            <param name="neatPop">A pre constructed/loaded neat population; this must be compatible with the provided
            neat experiment, otherwise an exception will be thrown.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatUtils.CreateNeatEvolutionAlgorithm(SharpNeat.Experiments.INeatExperiment{System.Double})">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1"/> for the given neat experiment.
            </summary>
            <param name="neatExperiment">A neat experiment instance; this conveys everything required to create a new
            evolution algorithm instance that is ready to be run.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithm`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.NeatUtils.CreateMetaNeatGenome(SharpNeat.Experiments.INeatExperiment{System.Double})">
            <summary>
            Create a <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/> based on the parameters supplied by an
            <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/>.
            </summary>
            <param name="neatExperiment">The neat experiment.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.MetaNeatGenome`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.MutationType">
            <summary>
            Genome mutation types.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions">
            <summary>
            Container for <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> instances that represent discrete probability distributions
            over the set of possible genome mutation types.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.MutationTypeDistribution">
            <summary>
            The genome mutation type probability settings represented as a <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.MutationTypeDistributionNonDestructive">
            <summary>
            A copy of <see cref="P:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.MutationTypeDistribution"/> but with all destructive mutations (i.e. delete connections)
            removed. Useful when e.g. mutating a genome with very few connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.#ctor(SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="settings">Asexual reproduction settings.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.CreateMutationTypeDiscreteDistribution(SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings)">
            <summary>
            Create a new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> that represents all of the possible
            genome mutation types, and their relative probabilities.
            </summary>
            <param name="settings">Asexual reproduction settings.</param>
            <returns>A new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.MutationTypeDistributions.CreateMutationTypeDiscreteDistribution_NonDestructive(SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings)">
            <summary>
            Create a new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/> that represents a subset of the possible
            genome mutation types, and their relative probabilities. The subset consists of mutation types that
            are non-destructive (i.e. weight mutation, add node mutation, add connection mutation).
            </summary>
            <param name="settings">Asexual reproduction settings.</param>
            <returns>A new instance of <see cref="T:Redzen.Numerics.Distributions.Double.DiscreteDistribution"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual`1">
            <summary>
            Creation of offspring given a single parent (asexual reproduction).
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,SharpNeat.Neat.AddedNodeBuffer,SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings,SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme{`0})">
            <summary>
            Construct a new instance.
            </summary>
            <param name="metaNeatGenome">NeatGenome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="innovationIdSeq">Innovation ID sequence; for obtaining new innovation IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
            <param name="addedNodeBuffer">A history buffer of added nodes.</param>
            <param name="settings">Asexual reproduction settings.</param>
            <param name="weightMutationScheme">Connection weight mutation scheme.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual`1.NotifyComplexityRegulationMode(SharpNeat.Neat.ComplexityRegulation.ComplexityRegulationMode)">
            <summary>
            Notify the strategy of a change in complexity regulation mode in the evolution algorithm.
            </summary>
            <param name="mode">The current mode.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings">
            <summary>
            Settings related to <see cref="T:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexual`1"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.ConnectionWeightMutationProbability">
            <summary>
            Probability that a genome mutation is a connection weights mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.AddNodeMutationProbability">
            <summary>
            Probability that a genome mutation is an 'add node' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.AddConnectionMutationProbability">
            <summary>
            Probability that a genome mutation is an 'add connection' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.DeleteConnectionMutationProbability">
            <summary>
            Probability that a genome mutation is a 'delete connection' mutation.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.#ctor(SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings)">
            <summary>
            Copy constructor.
            </summary>
            <param name="copyFrom">The settings object to copy.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.CreateSimplifyingSettings">
            <summary>
            Creates a new settings object based on the current settings object, but modified to be suitable for use when
            the evolution algorithm is in simplifying mode.
            </summary>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.NeatReproductionAsexualSettings.Validate">
            <summary>
            Validate the settings, and throw an exception if not valid.
            </summary>
            <remarks>
            As a 'simple' collection of properties there is no construction time check that can be performed, therefore this method is supplied to
            allow consumers of a settings object to validate it before using it.
            </remarks>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddAcyclicConnectionStrategy`1">
            <summary>
            A NEAT genome asexual reproduction strategy based on adding a single acyclic connection.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <remarks>
            Offspring genomes are created by taking a clone of a single parent genome and adding a single acyclic connection,
            if possible.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddAcyclicConnectionStrategy`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="metaNeatGenome">NEAT genome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddAcyclicConnectionStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddConnectionUtils">
            <summary>
            Static utility methods related to the adding connections to a genome. I.e., am 'add connection' mutation.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddConnectionUtils.GetNodeIdFromIndex``1(SharpNeat.Neat.Genome.NeatGenome{``0},System.Int32)">
            <summary>
            Gets the ID of the node with the specified node index.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
            <param name="parent">Parent genome.</param>
            <param name="idx">Node index.</param>
            <returns>The ID of the node with the specified node index.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddCyclicConnectionStrategy`1">
            <summary>
            A NEAT genome asexual reproduction strategy based on adding a single connection.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <remarks>
            Offspring genomes are created by taking a clone of a single parent genome and adding a single connection,
            if possible.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddCyclicConnectionStrategy`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="metaNeatGenome">NEAT genome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddCyclicConnectionStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddNodeStrategy`1">
            <summary>
            A NEAT genome asexual reproduction strategy based on adding a single node.
            </summary>
            <typeparam name="T">Neural network numeric data type.</typeparam>
            <remarks>
            Offspring genomes are created by taking a clone of a single parent genome and adding a single node,
            if possible. A node is added by selecting a connection at random, and splitting it, i.e. replacing
            A → B with A → C → B, where A and B are the existing nodes, and C is the new node.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddNodeStrategy`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,SharpNeat.Neat.AddedNodeBuffer)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="metaNeatGenome">NEAT genome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="innovationIdSeq">Innovation ID sequence; for obtaining new innovation IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
            <param name="addedNodeBuffer">A history buffer of added nodes.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddNodeStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <summary>
            Create a new child genome from a given parent genome.
            </summary>
            <param name="parent">The parent genome.</param>
            <param name="rng">Random source.</param>
            <returns>A new child genome.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.AddNodeStrategy`1.GetHiddenNodeIdArray(SharpNeat.Neat.Genome.NeatGenome{`0},System.Int32,System.Boolean)">
            <summary>
            Get an array of hidden node IDs in the child genome.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1">
            <summary>
            A NEAT genome asexual reproduction strategy based on deletion of a single connection.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <remarks>
            Offspring genomes are created by taking a clone of a single parent genome and deleting a single
            connection, if possible.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.#ctor(SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.GetHiddenNodeIdArray(SharpNeat.Neat.Genome.NeatGenome{`0},System.Int32,SharpNeat.Graphs.DirectedConnection[])">
            <summary>
            Get an array of hidden node IDs in the child genome.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.GetDeletedNodeIds(SharpNeat.Neat.Genome.NeatGenome{`0},System.Int32,SharpNeat.Graphs.DirectedConnection[])">
            <summary>
            Determine the set of hidden node IDs that have been deleted as a result of a connection deletion.
            I.e. a node only exists if a connection connects to it, therefore if there are no other connections
            referring to a node then it has been deleted, with the exception of input and output nodes that
            always exist.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.IsNodeConnectedTo(SharpNeat.Graphs.DirectedConnection[],System.Int32)">
            <summary>
            Is nodeId referred to by any of the connections in connArr.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.DeleteConnectionStrategy`1.AreNodesConnectedTo(SharpNeat.Graphs.DirectedConnection[],System.Int32,System.Int32)">
            <summary>
            Are nodeId1 and nodeId2 connected to by any of the connections in connArr.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.IAsexualReproductionStrategy`1">
            <summary>
            Represents a NEAT genome asexual reproduction strategy.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.IAsexualReproductionStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <summary>
            Create a new child genome from a given parent genome.
            </summary>
            <param name="parent">The parent genome.</param>
            <param name="rng">Random source.</param>
            <returns>A new child genome.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.Strategy.MutateWeightsStrategy`1">
            <summary>
            A NEAT genome asexual reproduction strategy based on mutation of connection weights.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <remarks>
            Offspring genomes are created by taking a clone of a single parent genome and applying a weight
            mutation scheme to the connection weights of the clone.
            </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.MutateWeightsStrategy`1.#ctor(SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme{`0})">
            <summary>
            Construct a new instance.
            </summary>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
            <param name="weightMutationScheme">Connection weight mutation scheme.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.Strategy.MutateWeightsStrategy`1.CreateChildGenome(SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy">
            <summary>
            A connection weight mutation strategy that applies deltas to existing weights.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy.#ctor(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,Redzen.Numerics.Distributions.IStatelessSampler{System.Double})">
            <summary>
            Construct a new instance.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="weightDeltaSampler">Weight delta sampler.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy.Invoke(System.Double[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy.CreateUniformDeltaStrategy(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,System.Double)">
            <summary>
            Create a weight mutation strategy that applies deltas to a random subset of weights, with deltas sampled from a uniform distribution.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="weightScale">The uniform distribution scale.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy.CreateGaussianDeltaStrategy(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,System.Double)">
            <summary>
             Create a weight mutation strategy that applies deltas to a random subset of weights, with deltas sampled from a Gaussian distribution.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="stdDev">Gaussian standard deviation.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Double.DeltaWeightMutationStrategy"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.IWeightMutationStrategy`1">
            <summary>
            A connection weight mutation strategy.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.IWeightMutationStrategy`1.Invoke(`0[],Redzen.Random.IRandomSource)">
            <summary>
            Invoke the strategy.
            </summary>
            <param name="weightArr">The connection weight array to apply mutations to.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1">
            <summary>
            A connection weight mutation strategy that resets connection weights.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1.#ctor(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,Redzen.Numerics.Distributions.IStatelessSampler{`0})">
            <summary>
            Construct with the given selection strategy and weight sampler.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="weightSampler">Weight sampler.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1.Invoke(`0[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1.CreateUniformResetStrategy(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,System.Double)">
            <summary>
            Create a weight mutation strategy that replaces a random subset of weights, with new weights sampled
            from a uniform distribution.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="weightScale">The uniform distribution scale.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1.CreateGaussianResetStrategy(SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy,System.Double)">
            <summary>
            Create a weight mutation strategy that replaces a random subset of weights, with new weights sampled
            from a Gaussian distribution.
            </summary>
            <param name="selectionStrategy">Weight selection strategy.</param>
            <param name="stdDev">Gaussian standard deviation.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.ResetWeightMutationStrategy`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.CardinalSubsetSelectionStrategy">
            <summary>
            Strategy for selecting a sub-set of items from a superset.
            The number of items to select is a fixed number (the selection cardinality), unless the superset is smaller
            in which case all items in the superset are selected.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.CardinalSubsetSelectionStrategy.#ctor(System.Int32)">
            <summary>
            Construct with the given selection count (selection cardinality).
            </summary>
            <param name="selectCount">The number of items to select.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.CardinalSubsetSelectionStrategy.SelectSubset(System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy">
            <summary>
            Strategy for selecting a sub-set of items from a superset.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ISubsetSelectionStrategy.SelectSubset(System.Int32,Redzen.Random.IRandomSource)">
            <summary>
            Select a subset of items from a superset of a given size.
            </summary>
            <param name="supersetCount">The size of the superset to select from.</param>
            <param name="rng">Random source.</param>
            <returns>An array of indexes that are the selected items.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ProportionSubsetSelectionStrategy">
            <summary>
            Strategy for selecting a sub-set of items from a superset.
            The number of items to select is a fixed proportion of the superset size.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ProportionSubsetSelectionStrategy.#ctor(System.Double)">
            <summary>
            Construct with the given selection proportion.
            </summary>
            <param name="selectionProportion">The proportion of items to select.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.Selection.ProportionSubsetSelectionStrategy.SelectSubset(System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme`1">
            <summary>
            Connection weight mutation scheme.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme`1.#ctor(System.Double[],SharpNeat.Neat.Reproduction.Asexual.WeightMutation.IWeightMutationStrategy{`0}[])">
            <summary>
            Construct a new instance with the given strategy arguments.
            </summary>
            <param name="strategyProbabilityArr">An array of strategy selection probabilities.</param>
            <param name="mutationStrategyArr">An array of weight mutation strategies.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme`1.MutateWeights(`0[],Redzen.Random.IRandomSource)">
            <summary>
            Mutate the connection weights based on a stochastically chosen <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.IWeightMutationStrategy`1"/>.
            </summary>
            <param name="weightArr">The connection weight array to apply mutations to.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationSchemeFactory">
            <summary>
            Static factory methods for creation of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme`1"/> instances.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationSchemeFactory.CreateDefaultScheme(System.Double)">
             <summary>
             Create the default connection weight scheme.
             </summary>
             <remarks>
             The scheme currently in use is taken from SharpNEAT version 2.x, i.e. this is the long standing default scheme
             in sharpneat. There has been little to no exploration of what schemes are good and whether this scheme in particular
             is good, as such this is a candidate for future research and improvements.
            
             At time of writing it was thought wise to adopt the scheme from SharpNEAT 2.x because the code base is being
             rewritten/refactored and it is therefore useful to keep schemes such as this as close to the previous version as
             possible to assist in debugging and testing of the new code base by comparing performance/results, etc. with the 2.x
             code base.
             </remarks>
             <param name="weightScale">Connection weight scale/range.</param>
             <returns>A new instance of <see cref="T:SharpNeat.Neat.Reproduction.Asexual.WeightMutation.WeightMutationScheme`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexual`1">
            <summary>
            Creation of offspring given two parents (sexual reproduction).
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexual`1.#ctor(SharpNeat.Neat.Genome.MetaNeatGenome{`0},SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence,SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexualSettings)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="metaNeatGenome">NeatGenome metadata.</param>
            <param name="genomeBuilder">NeatGenome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">Generation sequence; for obtaining the current generation number.</param>
            <param name="settings">Sexual reproduction settings.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexual`1.CreateGenome(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexualSettings">
            <summary>
            Settings related to <see cref="T:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexual`1"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexualSettings.SecondaryParentGeneProbability">
            <summary>
            The probability that a gene that exists only on the secondary parent is copied into the child genome.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.NeatReproductionSexualSettings.Validate">
            <summary>
            Validate the settings, and throw an exception if not valid.
            </summary>
            <remarks>
            As a 'simple' collection of properties there is no construction time check that can be performed, therefore this method is supplied to
            allow consumers of a settings object to validate it before using it.
            </remarks>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.ISexualReproductionStrategy`1">
            <summary>
            Represents a NEAT genome sexual reproduction strategy.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.ISexualReproductionStrategy`1.CreateGenome(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <summary>
            Create a new child genome based on the genetic content of two parent genome.
            </summary>
            <param name="parent1">Parent 1.</param>
            <param name="parent2">Parent 2.</param>
            <param name="rng">Random source.</param>
            <returns>A new child genome.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGene`1">
            <summary>
            Represents a single connection gene.
            </summary>
            <typeparam name="T">Connection weight numeric data type.</typeparam>
        </member>
        <member name="F:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGene`1.Endpoints">
            <summary>
            The source and target node IDs.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGene`1.Weight">
            <summary>
            Connection weight.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGene`1.#ctor(SharpNeat.Graphs.DirectedConnection@,`0)">
            <summary>
            Construct with the given connection node endpoints, and connection weight.
            </summary>
            <param name="endpoints">The connection endpoints, i.e., the connection's source and target node IDs.</param>
            <param name="weight">The connection weight.</param>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGeneListBuilder`1">
            <summary>
            Helper class for building lists of connections.
            </summary>
            <typeparam name="T">Connection weight numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGeneListBuilder`1.#ctor(System.Boolean,System.Int32)">
            <summary>
            Construct with the given acyclic flag and initial capacity.
            </summary>
            <param name="isAcyclic">Indicates whether we are building acyclic networks or not.</param>
            <param name="capacity">Initial capacity.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGeneListBuilder`1.TryAddGene(SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGene{`0}@)">
            <summary>
            Add a Gene to the builder, but only if the connection is not already present (as determined by its source and target ID endpoints).
            </summary>
            <param name="gene">The connection gene to add.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGeneListBuilder`1.ToConnectionGenes">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/> that contains a copy of the current connections.
            </summary>
            <returns>A new instance of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.ConnectionGeneListBuilder`1.Clear">
            <summary>
            Clear connections (if any).
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck">
             <summary>
             For checking/testing if a proposed new connection on a NEAT genome would form a connectivity cycle.
             </summary>
             <remarks>
             This class utilises a depth first graph traversal algorithm to check if a proposed new connection on a given
             graph would form a cycle, as such it is assumed that the graph as given is acyclic, if it isn't then the graph
             traversal stack will grown to infinity, ultimately resulting in an OutOfMemory exception.
            
             The algorithm will perform a full depth first traversal of the graph starting at the proposed new connection's
             target node, and if that connection's source node is encountered then it would form a cycle if it were added
             to the graph.
            
             Each instance of this class allocates a stack and a hashset for use by the traversal algorithm, and these
             are cleared and re-used for each call to IsConnectionCyclic(). This avoids memory re-allocation and garbage
             collection overhead, but the side effect is that IsConnectionCyclic() is not reentrant, i.e. can only be in
             use by one execution thread at a given point in time. A reentrancy check will throw an exception if reentrancy
             is attempted.
            
            
             Implementation Details / Notes
             ----------------------
             This class is optimized for speed and efficiency and as such is tightly coupled with the connection gene list
             data structure, and is perhaps not as easy to read/understand as a traditional depth first graph traversal
             algorithm using function recursion. However this is essentially a depth first graph traversal algorithm that
             utilises its own stack instead of using the call stack.
            
             The traversal stack is a stack of Int32(s), each of which is an index into connList (the list of connections
             that make up the graph, ordered by sourceId and then targetId). Thus, each stack entry points to a connection,
             and represents traversal of that connection's source node and also which of that node's child connections/nodes
             is the current traversal position/path from that node (note. this works because the connections are sorted by
             sourceId first).
            
             As such this algorithm has a far more compact stack frame than the equivalent algorithm implemented as a
             recursive function, and avoids any other method call overhead as a further performance benefit (i.e. overhead
             other than stack frame initialisation).
            
             The main optimizations then are:
            
                * No method call overhead from recursive method calls.
            
                * Each stack frame is a single int32 and thus the stack as a whole is highly compact; this improves CPU cache
                  locality and hit rate, and also keeps the max size of the stack for any given traversal at a minimum.
            
                * The stack and a visitedNodes HashSet are allocated for each class instance and are cleared and re-used for each
                  call to IsConnectionCyclic(), therefore minimizing memory allocation and garbage collection overhead.
            
                * Using a stack on the heap also avoids any potential for a stack overflow on very deep graphs, which could occur
                  if using method call recursion.
            
             Problems with the approach of this class are:
            
                * The code is more complex than the same algorithm written as a recursive function; this makes the code harder
                  to read, understand and maintain, thus increasing the probability of subtle defects.
            
             Also see:
             <see cref="T:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck"/>
             <see cref="T:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis"/>
             <see cref="T:SharpNeat.Graphs.CyclicGraphCheck"/>.
             </remarks>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck.IsConnectionCyclic(System.Span{SharpNeat.Graphs.DirectedConnection},SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Tests if the proposed new connection <paramref name="newConn"/> would form a cycle if added to the
            existing directed acyclic graph described by connArr.
            </summary>
            <param name="connSpan">A set of connections that describe a directed acyclic graph.</param>
            <param name="newConn">A proposed new connection to add to the graph.</param>
            <returns>True if <paramref name="newConn"/> would form a cycle; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck.TraverseGraph(System.Span{SharpNeat.Graphs.DirectedConnection},System.Int32)">
            <summary>
            The graph traversal algorithm.
            </summary>
            <param name="connSpan">A set of connections that represents the graph to traverse.</param>
            <param name="terminalNodeId">// The 'terminal' node ID, i.e. if traversal reaches this node then newConn would form a cycle and we stop/terminate traversal.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck.MoveForward(System.Span{SharpNeat.Graphs.DirectedConnection},System.Int32)">
            <summary>
            Update the stack state to point to the next connection to traverse down.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.UniformCrossoverReproductionStrategy`1">
             <summary>
             Uniform crossover.
            
             The genes of the two parent genomes are aligned by innovation ID. The new child genome
             takes genes from each of the parents with a given probability (e.g. 50%).
             </summary>
             <typeparam name="T">Neural network numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.UniformCrossoverReproductionStrategy`1.#ctor(System.Boolean,System.Double,SharpNeat.Neat.Genome.INeatGenomeBuilder{`0},Redzen.Structures.Int32Sequence,Redzen.Structures.Int32Sequence)">
            <summary>
            Construct with the given strategy arguments.
            </summary>
            <param name="isAcyclic">Indicates that the strategy will be operating on acyclic graphs/genomes.</param>
            <param name="secondaryParentGeneProbability">The probability that a gene that exists only on the secondary parent is copied into the child genome.</param>
            <param name="genomeBuilder">A neat genome builder.</param>
            <param name="genomeIdSeq">Genome ID sequence; for obtaining new genome IDs.</param>
            <param name="generationSeq">A sequence that provides the current generation number.</param>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.UniformCrossoverReproductionStrategy`1.CreateGenome(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Genome.NeatGenome{`0},Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.UniformCrossoverReproductionStrategyUtils">
            <summary>
            Static utility methods for the uniform crossover reproduction strategy.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.UniformCrossoverReproductionStrategyUtils.EnumerateParentGenes``1(SharpNeat.Neat.Genome.ConnectionGenes{``0},SharpNeat.Neat.Genome.ConnectionGenes{``0})">
            <summary>
            Performs a 'parallel walk' over the connection genes of parent1 and parent2.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="parent1">Parent 1.</param>
            <param name="parent2">Parent 2.</param>
            <returns>An enumerable over indexes into parent1 and parent2's connection genes.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationInit`1">
             <summary>
             GeneticKMeansSpeciationStrategy initialisation.
            
             This class handles initialising the k-means clusters (species), i.e. it takes a population of genomes
             and forms an initial set of k-means clusters with which to begin running the k-means iterations upon.
             upon.
            
             Note. this implementation applies a modified version of the k-means++ initialisation method.
             </summary>
             <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationInit`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0})">
            <summary>
            Construct with the given distance metric.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationInit`1.InitialiseSpecies(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <summary>
            Group the provided genomes into new species.
            </summary>
            <param name="genomeList">The genomes to partition into groups/species.</param>
            <param name="speciesCount">The required number of species.</param>
            <param name="rng">Random source.</param>
            <returns>A new array of <see cref="T:SharpNeat.Neat.Speciation.Species`1"/>, with each species containing a subset of the genomes from <paramref name="genomeList"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationStrategy`1">
            <summary>
            A speciation strategy that assigns genomes to species using k-means clustering on the genes of each genome.
            </summary>
            <remarks>
            This is the speciation scheme used in SharpNEAT 2.x.
            </remarks>
            <typeparam name="T">Neural net signal and weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationStrategy`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0},System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="maxKMeansIters">Maximum number of k-means iterations.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationStrategy`1.SpeciateAll(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.GeneticKMeansSpeciationStrategy`1.SpeciateAdd(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationInit`1">
             <summary>
             GeneticKMeansSpeciationStrategy initialisation.
            
             This class handles initialising the k-means clusters (species), i.e. it takes a population of genomes
             and forms an initial set of k-means clusters with which to begin running the k-means iterations upon.
             upon.
            
             Note. this implementation applies a modified version of the k-means++ initialisation method.
             </summary>
             <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationInit`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Construct with the given distance metric.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="parallelOptions">Parallel options.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationInit`1.InitialiseSpecies(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <summary>
            Group the provided genomes into new species.
            </summary>
            <param name="genomeList">The genomes to partition into groups/species.</param>
            <param name="speciesCount">The required number of species.</param>
            <param name="rng">Random source.</param>
            <returns>A new array of <see cref="T:SharpNeat.Neat.Speciation.Species`1"/>, with each species containing a subset of the genomes from <paramref name="genomeList"/>.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationStrategy`1">
             <summary>
             A speciation strategy that assigns genomes to species using k-means clustering on the genes of each genome.
             </summary>
             <remarks>
             This is the speciation scheme used in SharpNEAT 2.x.
            
             This is a multi-threaded equivalent of GeneticKMeansSpeciationStrategy, i.e. when calling the speciation methods
             SpeciateAll() and SpeciateAdd(), this class will distribute workload to multiple threads to allow utilisation
             of multiple CPU cores if available.
            
             Multi-threading is achieved using the .NET framework's Parallel classes, and thus by default will adjust to utilise
             however many CPU cores are available.
             </remarks>
             <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationStrategy`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0},System.Int32,System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="maxKMeansIters">Maximum number of k-means iterations.</param>
            <param name="degreeOfParallelism">The number of CPU threads to distribute work to.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationStrategy`1.SpeciateAll(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.GeneticKMeansSpeciationStrategy`1.SpeciateAdd(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1">
             <summary>
             A speciation strategy that assigns genomes to species using k-means clustering on the genes of each genome.
             </summary>
             <remarks>
             This class applies a regularized k-means method as described in this paper:
                "REGULARISED k-MEANS CLUSTERING FOR DIMENSION REDUCTION APPLIED TO SUPERVISED CLASSIFICATION",
                Vladimir Nikulin, Geoffrey J. McLachlan, Department of Mathematics, University of Queensland, Brisbane, Australia.
                https://people.smp.uq.edu.au/GeoffMcLachlan/cibb/nm_cibb09.pdf
            
             The intent of regularization is to discourage formation of large dominating clusters (species), and instead to
             encourage more even distribution of genomes amongst clusters, and also the formation of more stable clusters.
            
             Regularization works as follows. In standard k-means the genomes are allocated to species who's centroid they are
             nearest to, the regularization method in use here adjusts the calculated genome-centroid distances to include an
             additional regularization term, like so:
            
                 adjustedDistance = distance + regularitationTerm
            
             The regularization term (r) is calculated as follows:
            
                 r = (c/populationSize) * L * alpha
            
             Where:
                 c is a cluster size (species size).
                 alpha is a constant scaling factor.
                 L is the maximum distance between any two species centroid.
            
             Thus, the term (c/populationSize) is a proportion ranging over the interval [0,1], where small clusters are
             near to zero and large cluster are nearer 1. As such the regularization term will be higher for larger clusters
             and therefore any genomes on he edges of a large cluster may be allocated to a nearby smaller cluster instead.
            
             L is intended to represent the magnitudes of the distances being dealt with, i.e. it makes the regularization
             method as a whole 'scale free'. The calculation for L used in this class differs from that used in the paper
             referred to above, but the intention is the same, i.e. to obtain some stable value that is representative of
             the magnitude of the distances being dealt with.
            
             In the referred to paper L is taken to be the maximum distance between any genome and any specie centroid. In
             this class we take the maximum distance between any two species centroids, this should result in a scale free
             distance that serves the same purpose, but that is faster to compute. This version of L will tend to be smaller
             that the version used in the paper, but we can adjust alpha (the constant scaling factor) accordingly.
            
             At time of writing this class is experimental and has not been scientifically examined for suitability or
             efficacy in particular in comparison to the standard k-means method.
             </remarks>
             <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0},System.Int32,System.Double,System.Int32)">
            <summary>
            Construct with the provided distance metric and k-means settings.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="maxKMeansIters">Maximum number of k-means iterations.</param>
            <param name="regularizationConstant">Regularization constant.</param>
            <param name="degreeOfParallelism">The number of CPU threads to distribute work to.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.SpeciateAll(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.SpeciateAdd(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.DetermineGenomeSpecies(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Speciation.Species{`0}[],System.Double,System.Double)">
            <summary>
            Determine which species the given genome belongs to.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.GetAdjustedDistance(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Speciation.Species{`0},System.Double,System.Double)">
            <summary>
            Gets an adjusted distance between the given genome and a species centroid.
            The adjustment introduces a regularization term.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.Parallelized.RegularizedGeneticKMeansSpeciationStrategy`1.GetMaxIntraSpeciesCentroidDistance(SharpNeat.Neat.Speciation.Species{`0}[])">
            <summary>
            Calc the maximum distance between any two centroids.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1">
             <summary>
             A speciation strategy that assigns genomes to species using k-means clustering on the genes of each genome.
             </summary>
             <remarks>
             This class applies a regularized k-means method as described in this paper:
                "REGULARISED k-MEANS CLUSTERING FOR DIMENSION REDUCTION APPLIED TO SUPERVISED CLASSIFICATION",
                Vladimir Nikulin, Geoffrey J. McLachlan, Department of Mathematics, University of Queensland, Brisbane, Australia.
                https://people.smp.uq.edu.au/GeoffMcLachlan/cibb/nm_cibb09.pdf
            
             The intent of regularization is to discourage formation of large dominating clusters (species), and instead to
             encourage more even distribution of genomes amongst clusters, and also the formation of more stable clusters.
            
             Regularization works as follows. In standard k-means the genomes are allocated to species who's centroid they are
             nearest to, the regularization method in use here adjusts the calculated genome-centroid distances to include an
             additional regularization term, like so:
            
                 adjustedDistance = distance + regularitationTerm
            
             The regularization term (r) is calculated as follows:
            
                 r = (c/populationSize) * L * alpha
            
             Where:
                 c is a cluster size (species size).
                 alpha is a constant scaling factor.
                 L is the maximum distance between any two species centroid.
            
             Thus, the term (c/populationSize) is a proportion ranging over the interval [0,1], where small clusters are
             near to zero and large cluster are nearer 1. As such the regularization term will be higher for larger clusters
             and therefore any genomes on he edges of a large cluster may be allocated to a nearby smaller cluster instead.
            
             L is intended to represent the magnitudes of the distances being dealt with, i.e. it makes the regularization
             method as a whole 'scale free'. The calculation for L used in this class differs from that used in the paper
             referred to above, but the intention is the same, i.e. to obtain some stable value that is representative of
             the magnitude of the distances being dealt with.
            
             In the referred to paper L is taken to be the maximum distance between any genome and any specie centroid. In
             this class we take the maximum distance between any two species centroids, this should result in a scale free
             distance that serves the same purpose, but that is faster to compute. This version of L will tend to be smaller
             that the version used in the paper, but we can adjust alpha (the constant scaling factor) accordingly.
            
             At time of writing this class is experimental and has not been scientifically examined for suitability or
             efficacy in particular in comparison to the standard k-means method.
             </remarks>
             <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.#ctor(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{`0},System.Int32,System.Double)">
            <summary>
            Construct with the provided distance metric and k-means settings.
            </summary>
            <param name="distanceMetric">Distance metric.</param>
            <param name="maxKMeansIters">Maximum number of k-means iterations.</param>
            <param name="regularizationConstant">Regularization constant.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.SpeciateAll(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},System.Int32,Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.SpeciateAdd(System.Collections.Generic.IList{SharpNeat.Neat.Genome.NeatGenome{`0}},SharpNeat.Neat.Speciation.Species{`0}[],Redzen.Random.IRandomSource)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.DetermineGenomeSpecies(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Speciation.Species{`0}[],System.Double,System.Double)">
            <summary>
            Determine which species the given genome belongs to.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.GetAdjustedDistance(SharpNeat.Neat.Genome.NeatGenome{`0},SharpNeat.Neat.Speciation.Species{`0},System.Double,System.Double)">
            <summary>
            Gets an adjusted distance between the given genome and a species centroid.
            The adjustment introduces a regularization term.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.GeneticKMeans.RegularizedGeneticKMeansSpeciationStrategy`1.GetMaxIntraSpeciesCentroidDistance(SharpNeat.Neat.Speciation.Species{`0}[])">
            <summary>
            Calc the maximum distance between any two centroids.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.ISpeciationStrategy`2">
            <summary>
            Represents a NEAT speciation strategy.
            </summary>
            <typeparam name="TGenome">Genome type.</typeparam>
            <typeparam name="TWeight">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.ISpeciationStrategy`2.SpeciateAll(System.Collections.Generic.IList{`0},System.Int32,Redzen.Random.IRandomSource)">
            <summary>
            Initialise a new set of species based on the provided population of genomes and the
            speciation method in use.
            </summary>
            <param name="genomeList">The genomes to speciate.</param>
            <param name="speciesCount">The number of required species.</param>
            <param name="rng">Random source.</param>
            <returns>A new array of species.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.ISpeciationStrategy`2.SpeciateAdd(System.Collections.Generic.IList{`0},SharpNeat.Neat.Speciation.Species{`1}[],Redzen.Random.IRandomSource)">
            <summary>
            Merge new genomes into an existing set of species.
            </summary>
            <param name="genomeList">A list of genomes that have not yet been assigned a species.</param>
            <param name="speciesArr">An array of pre-existing species.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.SpeciationUtils">
            <summary>
            Static utility methods related to speciation.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.SpeciationUtils.GetNearestSpecies``1(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{``0},SharpNeat.Neat.Genome.NeatGenome{``0},SharpNeat.Neat.Speciation.Species{``0}[])">
            <summary>
            Get the index of the species with a centroid that is nearest to the provided genome.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="distanceMetric">Distance metric.</param>
            <param name="genome">The genome.</param>
            <param name="speciesArr">An array of species to compare the genome with.</param>
            <returns>The index of the species that is nearest to <paramref name="genome"/>.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.SpeciationUtils.PopulateEmptySpecies``1(SharpNeat.Neat.DistanceMetrics.IDistanceMetric{``0},SharpNeat.Neat.Speciation.Species{``0}[],SharpNeat.Neat.Speciation.Species{``0}[])">
            <summary>
            Populate empty species with a single genome.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="distanceMetric">Distance metric.</param>
            <param name="emptySpeciesArr">An array of empty species that are to be populated.</param>
            <param name="speciesArr">An array of all species.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.SpeciationUtils.ExtractConnectionGenes``1(System.Collections.Generic.List{SharpNeat.Neat.Genome.ConnectionGenes{``0}},System.Collections.Generic.Dictionary{System.Int32,SharpNeat.Neat.Genome.NeatGenome{``0}})">
            <summary>
            Populate a list of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/> with the connection genes from a dictionary of
            <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="targetList">The list to populate.</param>
            <param name="genomeById">The dictionary of genomes.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.SpeciationUtils.ExtractConnectionGenes``1(System.Collections.Generic.List{SharpNeat.Neat.Genome.ConnectionGenes{``0}},System.Collections.Generic.List{SharpNeat.Neat.Genome.NeatGenome{``0}})">
            <summary>
            Populate a list of <see cref="T:SharpNeat.Neat.Genome.ConnectionGenes`1"/> with the connection genes from a list of
            <see cref="T:SharpNeat.Neat.Genome.NeatGenome`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
            <param name="targetList">The list to populate.</param>
            <param name="genomeList">The list of genomes.</param>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.Species`1">
            <summary>
            Represents a NEAT species.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.Id">
            <summary>
            Species ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.Centroid">
            <summary>
            Species centroid.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.GenomeList">
            <summary>
            The genomes that are within the species.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.GenomeById">
            <summary>
            A working dictionary of genomes keyed by ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.PendingAddsList">
            <summary>
            Working list of genomes to be added to GenomeById at the end of a k-means iteration.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.PendingRemovesList">
            <summary>
            Working list of genome IDs to remove from GenomeById at the end of a k-means iteration.
            </summary>
        </member>
        <member name="P:SharpNeat.Neat.Speciation.Species`1.Stats">
            <summary>
            Species statistics.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.#ctor(System.Int32,SharpNeat.Neat.Genome.ConnectionGenes{`0},System.Int32)">
            <summary>
            Construct with the given species ID, centroid and initial capacity.
            </summary>
            <param name="id">Species ID.</param>
            <param name="centroid">Species centroid.</param>
            <param name="capacity">Initial capacity for the species genome list.</param>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.LoadWorkingDictionary">
            <summary>
            Transfer genomes from GenomeList into GenomeById.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.FlushWorkingDictionary">
            <summary>
            Transfer genomes from GenomeById into GenomeList.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.CompletePendingMoves">
            <summary>
            Complete all pending genome moves for this species.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.CalcTotalComplexity">
            <summary>
            Calculates the sum total complexity of all genomes within the species.
            </summary>
            <returns>The sum of <see cref="P:SharpNeat.EvolutionAlgorithm.IGenome.Complexity"/> for all genomes in the species.</returns>
        </member>
        <member name="M:SharpNeat.Neat.Speciation.Species`1.CalcMeanComplexity">
            <summary>
            Calculates the mean complexity of genomes within the species.
            </summary>
            <returns>The arithmetic mean of <see cref="P:SharpNeat.EvolutionAlgorithm.IGenome.Complexity"/> for all genomes in the species.</returns>
        </member>
        <member name="T:SharpNeat.Neat.Speciation.SpeciesStats">
            <summary>
            Species statistics.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.MeanFitness">
            <summary>
            The mean/average fitness of all genomes in the species.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.TargetSizeReal">
            <summary>
            The species target size. This is the real value from the target size calculation; this is 'resolved' to integer
            value <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.TargetSizeInt"/> to give the final/actual target size in the next generation.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.TargetSizeInt">
            <summary>
            The species target size.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.EliteSizeInt">
            <summary>
            The number of fittest genomes in the species to be kept in the species in the next generation.
            Thus the number of slots for new offspring is <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.TargetSizeInt"/> - <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.EliteSizeInt"/>.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringCount">
            <summary>
            The number of offspring genomes to produce for this species.
            This value is simply <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.TargetSizeInt"/> - <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.EliteSizeInt"/>.
            This count is broken down further into <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringAsexualCount"/> and <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringSexualCount"/>,
            i.e. <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringCount"/> = <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringAsexualCount"/> + <see cref="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringSexualCount"/>.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringAsexualCount">
            <summary>
            The number of offspring to produce through asexual reproduction.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.OffspringSexualCount">
            <summary>
            The number of offspring to produce through sexual reproduction.
            </summary>
        </member>
        <member name="F:SharpNeat.Neat.Speciation.SpeciesStats.SelectionSizeInt">
            <summary>
            The number of fittest genomes in the species to be selected from for selecting parents for sexual and asexual reproduction.
            </summary>
        </member>
        <member name="T:SharpNeat.Neat.SpeciesAllocationCalcs`1">
            <summary>
            Static method(s) for calculating species target size allocations.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Neat.SpeciesAllocationCalcs`1.UpdateSpeciesAllocationSizes(SharpNeat.Neat.NeatPopulation{`0},SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings,Redzen.Random.IRandomSource)">
            <summary>
            Calc and store species target sizes based on relative mean fitness of each species, i.e. as per NEAT fitness sharing method.
            Then calc and store the elite, selection and offspring allocations/counts, per species.
            </summary>
            <param name="pop">The NEAT population to update species allocation sizes for.</param>
            <param name="eaSettings">Evolution algorithm settings object.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="M:SharpNeat.Neat.SpeciesAllocationCalcs`1.CalcSpeciesTargetSizesInner_ZeroTotalMeanFitness(SharpNeat.Neat.NeatPopulation{`0},Redzen.Random.IRandomSource)">
            <summary>
            Handle specific case where all genomes/species have a zero fitness.
            </summary>
        </member>
        <member name="M:SharpNeat.Neat.SpeciesAllocationCalcs`1.UpdateEliteSelectionOffspringCounts(SharpNeat.Neat.NeatPopulation{`0},SharpNeat.Neat.EvolutionAlgorithm.NeatEvolutionAlgorithmSettings,Redzen.Random.IRandomSource)">
            <summary>
            For each species, allocate the EliteSizeInt, OffspringCount (broken down into OffspringAsexualCount and OffspringSexualCount),
            and SelectionSizeInt values.
            </summary>
            <param name="pop">The NEAT population to update species allocation sizes for.</param>
            <param name="eaSettings">Evolution algorithm settings object.</param>
            <param name="rng">Random source.</param>
        </member>
        <member name="T:SharpNeat.Experiments.ConfigModels.ComplexityRegulationStrategyConfig">
            <summary>
            Model type for NEAT complexity regulation strategy configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ComplexityRegulationStrategyConfig.StrategyName">
            <summary>
            Regulation strategy name.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ComplexityRegulationStrategyConfig.MinSimplifcationGenerations">
            <summary>
            The minimum number of generations we stay within simplification mode.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ComplexityRegulationStrategyConfig.RelativeComplexityCeiling">
            <summary>
            The relative complexity ceiling.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ComplexityRegulationStrategyConfig.ComplexityCeiling">
            <summary>
            The fixed/absolute complexity ceiling.
            </summary>
        </member>
        <member name="T:SharpNeat.Experiments.ConfigModels.ExperimentConfig">
            <summary>
            Model type for NEAT experiment configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.Id">
            <summary>
            A unique human-readable ID associated with the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.Name">
            <summary>
            Experiment name.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.Description">
            <summary>
            Experiment description.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.IsAcyclic">
            <summary>
            A boolean flag that indicates if the genomes that are evolved are acyclic,
            i.e. they should have no recurrent/cyclic connection paths.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.CyclesPerActivation">
            <summary>
            For cyclic neural networks (i.e. if <see cref="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.IsAcyclic"/> is false) this defines how many timesteps to
            run the neural net per call to Activate().
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.ActivationFnName">
            <summary>
            Name of the neuron activation function to use in evolved networks.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.EvolutionAlgorithm">
            <summary>
            NEAT evolution algorithm configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.ReproductionAsexual">
            <summary>
            NEAT asexual reproduction configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.ReproductionSexual">
            <summary>
            NEAT sexual reproduction configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.PopulationSize">
            <summary>
            The population size to use for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.InitialInterconnectionsProportion">
            <summary>
            The initial interconnections proportion. This is the proportion of possible
            direct connections from the input nodes to the output nodes that are to be created in
            each initial/seed genome. The connections to create are selected at random (using a
            select-without-replacement method).
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.ConnectionWeightScale">
            <summary>
            The maximum connection weight scale/magnitude.
            E.g. a value of 5 defines a weight range of -5 to 5.
            The weight range is strictly enforced, e.g. when creating new connections and mutating existing ones.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.ComplexityRegulationStrategy">
            <summary>
            Complexity regulation strategy configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.DegreeOfParallelism">
            <summary>
            The number of CPU threads to distribute work to.
            Set to -1 to use a thread count that matches the number of logical CPU cores.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.EnableHardwareAcceleratedNeuralNets">
             <summary>
             Enable use of hardware accelerated neural network implementations, i.e. alternative implementations that use
             CPU SIMD/vector instructions.
             </summary>
             <remarks>
             The vectorized code is provided by alternative classes, and these classes tend to be more complex than their
             'baseline' non-vectorized equivalents. Therefore when debugging a problem it is often useful to disable use
             of all vectorized code in order to rule out that code as the source of a problem/bug.
            
             Furthermore, enabling hardware acceleration has been observed to often result in slower execution speed,
             probably because NEAT deals with non-homogeneous, irregular neural network structures that are generally not
             conducive to the application of vectorized code.
             </remarks>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.ExperimentConfig.EnableHardwareAcceleratedActivationFunctions">
             <summary>
             Enable use of hardware accelerated neural network activation functions, i.e. alternative implementations that use
             CPU SIMD/vector instructions.
             </summary>
             <remarks>
             The vectorized code is provided by alternative classes, and these classes tend to be more complex than their
             'baseline' non-vectorized equivalents. Therefore when debugging a problem it is often useful to disable use
             of all vectorized code in order to rule out that code as the source of a problem/bug.
            
             Furthermore, enabling hardware acceleration has been observed to often result in slower execution speed,
             probably because NEAT deals with non-homogeneous, irregular neural network structures that are generally not
             conducive to the application of vectorized code.
             </remarks>
        </member>
        <member name="T:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig">
            <summary>
            Model type for NEAT evolution algorithm configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.SpeciesCount">
            <summary>
            The species count.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.ElitismProportion">
            <summary>
            Elitism proportion.
            We sort species genomes by fitness and keep the top N%, the other genomes are
            removed to make way for the offspring.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.SelectionProportion">
            <summary>
            Selection proportion.
            We sort species genomes by fitness and select parent genomes for producing offspring from
            the top N%. Selection is performed prior to elitism being applied, therefore selecting from more
            genomes than will be made elite is possible.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.OffspringAsexualProportion">
            <summary>
            The proportion of offspring to be produced from asexual reproduction (mutation).
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.OffspringSexualProportion">
            <summary>
            The proportion of offspring to be produced from sexual reproduction.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.InterspeciesMatingProportion">
            <summary>
            The proportion of sexual reproductions that will use genomes from different species.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatEvolutionAlgorithmConfig.StatisticsMovingAverageHistoryLength">
            <summary>
            Length of the history buffer used for calculating the moving average for best fitness, mean fitness and mean complexity.
            </summary>
        </member>
        <member name="T:SharpNeat.Experiments.ConfigModels.NeatReproductionAsexualConfig">
            <summary>
            Model type for NEAT asexual reproduction configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatReproductionAsexualConfig.ConnectionWeightMutationProbability">
            <summary>
            Probability that a genome mutation is a connection weights mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatReproductionAsexualConfig.AddNodeMutationProbability">
            <summary>
            Probability that a genome mutation is an 'add node' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatReproductionAsexualConfig.AddConnectionMutationProbability">
            <summary>
            Probability that a genome mutation is an 'add connection' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatReproductionAsexualConfig.DeleteConnectionMutationProbability">
            <summary>
            Probability that a genome mutation is a 'delete connection' mutation.
            </summary>
        </member>
        <member name="T:SharpNeat.Experiments.ConfigModels.NeatReproductionSexualConfig">
            <summary>
            Model type for NEAT sexual reproduction configuration.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.ConfigModels.NeatReproductionSexualConfig.SecondaryParentGeneProbability">
            <summary>
            The probability that a gene that exists only on the secondary parent is copied into the child genome.
            </summary>
        </member>
        <member name="T:SharpNeat.Experiments.INeatExperiment`1">
            <summary>
            An interface that brings together a number of settings objects that make up a given experiment.
            </summary>
            <typeparam name="T">Black box numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.FactoryId">
            <summary>
            Matches <see cref="P:SharpNeat.Experiments.INeatExperimentFactory.Id"/> from the experiment factory that created the current experiment instance.
            </summary>
            <remarks>
            It is possible to create <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> without using an <see cref="T:SharpNeat.Experiments.INeatExperimentFactory"/>, in those cases this
            property can be set to null.
            </remarks>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.Id">
            <summary>
            A unique human-readable ID associated with the experiment.
            </summary>
            <remarks>
            This will often match <see cref="P:SharpNeat.Experiments.INeatExperiment`1.FactoryId"/>, but there could be two or more experiments that are created from the same
            <see cref="T:SharpNeat.Experiments.INeatExperimentFactory"/> , and differ only by their configuration settings.
            </remarks>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.Name">
            <summary>
            Experiment name.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.Description">
            <summary>
            Experiment description.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.EvaluationScheme">
            <summary>
            Experiment evaluation scheme object.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.IsAcyclic">
            <summary>
            A boolean flag that indicates if the genomes that are evolved are acyclic,
            i.e. they should have no recurrent/cyclic connection paths.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.CyclesPerActivation">
            <summary>
            For cyclic neural networks (i.e. if <see cref="P:SharpNeat.Experiments.INeatExperiment`1.IsAcyclic"/> is false) this defines how many timesteps to run the neural net per call to Activate().
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.ActivationFnName">
            <summary>
            Name of the neuron activation function to use in evolved networks.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.EvolutionAlgorithmSettings">
            <summary>
            The <see cref="P:SharpNeat.Experiments.INeatExperiment`1.EvolutionAlgorithmSettings"/> to be used for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.ReproductionAsexualSettings">
            <summary>
            The asexual reproduction settings to use for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.ReproductionSexualSettings">
            <summary>
            The sexual reproduction settings to use for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.PopulationSize">
            <summary>
            The population size to use for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.InitialInterconnectionsProportion">
            <summary>
            The initial interconnections proportion. This is the proportion of possible
            direct connections from the input nodes to the output nodes that are to be created in
            each initial genome. The connections to create are selected at random (using a
            select-without-replacement method).
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.ConnectionWeightScale">
            <summary>
            The maximum connection weight scale/magnitude.
            E.g. a value of 5 defines a weight range of -5 to 5.
            The weight range is strictly enforced, e.g. when creating new connections and mutating existing ones.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.ComplexityRegulationStrategy">
            <summary>
            The complexity regulation strategy to use for the experiment.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.DegreeOfParallelism">
            <summary>
            The number of CPU threads to distribute work to.
            Set to -1 to use a thread count that matches the number of logical CPU cores.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.EnableHardwareAcceleratedNeuralNets">
             <summary>
             Enable use of hardware accelerated neural network implementations, i.e. alternate implementations that use
             CPU SIMD/vector instructions.
             </summary>
             <remarks>
             The vectorized code is provided by alternative classes, and these classes tend to be more complex than their
             'baseline' non-vectorized equivalents. Therefore when debugging a problem it is often useful to disable use
             of all vectorized code so as to rule out that code as the source of a problem/bug.
            
             Furthermore, enabling hardware acceleration has been observed to often result in slower execution speed,
             probably because NEAT deals with non-homogeneous, irregular neural network structures that are generally not
             conducive to the application of vectorized code.
             </remarks>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperiment`1.EnableHardwareAcceleratedActivationFunctions">
             <summary>
             Enable use of hardware accelerated neural network activation functions, i.e. alternate implementations that use
             CPU SIMD/vector instructions.
             </summary>
             <remarks>
             The vectorized code is provided by alternative classes, and these classes tend to be more complex than their
             'baseline' non-vectorized equivalents. Therefore when debugging a problem it is often useful to disable use
             of all vectorized code so as to rule out that code as the source of a problem/bug.
            
             Furthermore, enabling hardware acceleration has been observed to often result in slower execution speed,
             probably because NEAT deals with non-homogeneous, irregular neural network structures that are generally not
             conducive to the application of vectorized code.
             </remarks>
        </member>
        <member name="T:SharpNeat.Experiments.INeatExperimentFactory">
            <summary>
            Represents a factory of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/>.
            </summary>
        </member>
        <member name="P:SharpNeat.Experiments.INeatExperimentFactory.Id">
            <summary>
            Gets a unique human-readable ID for the experiment, e.g. 'binary-11-multiplexer'.
            </summary>
        </member>
        <member name="M:SharpNeat.Experiments.INeatExperimentFactory.CreateExperiment(System.IO.Stream)">
            <summary>
            Creates a new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> using the provided NEAT experiment
            configuration.
            </summary>
            <param name="jsonConfigStream">A stream from which experiment JSON configuration can be read.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Experiments.INeatExperimentFactory.CreateExperimentSinglePrecision(System.IO.Stream)">
            <summary>
             Creates a new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> using the provided NEAT experiment
            configuration, and using single-precision floating-point number format for the
            genome and neural-net connection weights.
            </summary>
            <param name="jsonConfigStream">A stream from which experiment JSON configuration can be read.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Experiments.ModelUtils">
            <summary>
            Static utility methods for working with strongly typed model classes.
            </summary>
        </member>
        <member name="M:SharpNeat.Experiments.ModelUtils.GetMandatoryProperty``2(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}})">
            <summary>
            Attempt to get a mandatory property from a model object.
            </summary>
            <typeparam name="TModel">Model type.</typeparam>
            <typeparam name="TPropertyValue">Type of the property to get.</typeparam>
            <param name="model">The model object that contains the property to get.</param>
            <param name="propertyExpression">Expression that refers to the required property on the model type.</param>
            <returns>The property value, if the property is not null.</returns>
            <exception cref="T:SharpNeat.ConfigurationException">Throw if the required property is null.</exception>
        </member>
        <member name="T:SharpNeat.Experiments.NeatExperiment`1">
            <summary>
            An aggregation of settings objects that make up a given experiment.
            </summary>
            <typeparam name="T">Black box numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Experiments.NeatExperiment`1.#ctor(SharpNeat.Evaluation.IBlackBoxEvaluationScheme{`0},System.String,System.String)">
            <summary>
            Constructs with the provided name and evaluation scheme, and default settings.
            </summary>
            <param name="evalScheme">Experiment evaluation scheme object.</param>
            <param name="factoryId">Experiment Factory ID.</param>
            <param name="id">Experiment ID (optional).</param>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.FactoryId">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.Id">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.Name">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.Description">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.EvaluationScheme">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.IsAcyclic">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.CyclesPerActivation">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.ActivationFnName">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.EvolutionAlgorithmSettings">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.ReproductionAsexualSettings">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.ReproductionSexualSettings">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.PopulationSize">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.InitialInterconnectionsProportion">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.ConnectionWeightScale">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.ComplexityRegulationStrategy">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.DegreeOfParallelism">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.EnableHardwareAcceleratedNeuralNets">
            <inheritdoc/>
        </member>
        <member name="P:SharpNeat.Experiments.NeatExperiment`1.EnableHardwareAcceleratedActivationFunctions">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Experiments.NeatExperimentExtensions">
            <summary>
            <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> extension methods.
            </summary>
        </member>
        <member name="M:SharpNeat.Experiments.NeatExperimentExtensions.Configure``1(SharpNeat.Experiments.INeatExperiment{``0},SharpNeat.Experiments.ConfigModels.ExperimentConfig)">
            <summary>
            Apply configuration to a given <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> instance.
            </summary>
            <param name="experiment">The NEAT experiment to configure.</param>
            <param name="experimentConfig">The configuration to apply.</param>
            <typeparam name="T">Experiment black-box numeric data type.</typeparam>
        </member>
        <member name="T:SharpNeat.Experiments.NeatExperimentFactoryExtensions">
            <summary>
            <see cref="T:SharpNeat.Experiments.INeatExperimentFactory"/> extension methods.
            </summary>
        </member>
        <member name="M:SharpNeat.Experiments.NeatExperimentFactoryExtensions.CreateExperiment(SharpNeat.Experiments.INeatExperimentFactory,System.String)">
            <summary>
            Creates a new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/> using the provided NEAT experiment
            configuration.
            </summary>
            <param name="experimentFactory">The experiment factory instance.</param>
            <param name="jsonConfigFilename">The name of a file from which experiment JSON configuration can be read.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Experiments.INeatExperiment`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis">
             <summary>
             An algorithm for calculating the depth of each node in an acyclic graph.
            
             Input nodes are defined as being at depth 0, the depth of all other nodes is defined as the maximum number
             of hops to each node from an input node. I.e. where multiple paths exist to a node (potentially each with
             a different numbers of hops), the node's depth is defined by the path with the most number of hops.
             </summary>
             <remarks>
             The algorithm utilises a depth first traversal of the graph, but using its own traversal stack data
             structure instead of relying on function recursion and the call stack. This is an optimisation, for more
             details see the comments on: <see cref="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck"/>.
             Also see:
             <see cref="T:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck"/>
             <see cref="T:SharpNeat.Graphs.CyclicGraphCheck"/>.
             </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.#ctor(System.Boolean)">
            <summary>
            Construct with a <paramref name="validateAcyclic"/> flag.
            </summary>
            <param name="validateAcyclic">If true then each call to <see cref="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.CalculateNodeDepths(SharpNeat.Graphs.DirectedGraph)"/> will test if
            the graph is cyclic before calculating the acyclic node depths. This is computationally expensive, and
            as such is intended to be used in debugging and testing scenarios only.</param>
            <remarks>
            If the caller can guarantee that calls to CalculateNodeDepths() will provide acyclic graphs only, then
            <paramref name="validateAcyclic"/> can be set to false to avoid the cost of the cyclic graph check (which is relatively expensive to perform).
            </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.CalculateNodeDepths(SharpNeat.Graphs.DirectedGraph)">
             <summary>
             Calculate node depths in an acyclic directed graph.
             </summary>
             <param name="digraph">The directed graph.</param>
             <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.GraphDepthInfo"/>.</returns>
             <remarks>
             If <paramref name="digraph"/> represents a cyclic graph, then this method will either
             (a) If validateAcyclic=true passed in at construction time, then an exception is thrown; otherwise
             (b) this method is non-completing, and will ultimately cause an out-of-memory exception.
            
             The cyclic test is expensive, therefore it should be avoided in normal use if possible, thus relying
             on the correctness of the caller, i.e., the caller should only ever call this method with acyclic
             graphs.
             </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.TraverseGraph(SharpNeat.Graphs.DirectedGraph)">
            <summary>
            The graph traversal algorithm.
            </summary>
            <param name="digraph">The directed acyclic graph to traverse.</param>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.MoveForward(System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis.StackFrame@)">
            <summary>
            Update the stack state to point to the next connection to traverse down.
            </summary>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck">
            <summary>
            For checking/testing if a new connection would form a connectivity cycle in an existing acyclic digraph.
            </summary>
            <remarks>
            The algorithm utilises a depth first traversal of the graph but using its own traversal stack
            data structure instead of relying on function recursion and the call stack. This is an optimisation,
            for more details see the comments on:
            <see cref="T:SharpNeat.Neat.Reproduction.Sexual.Strategy.UniformCrossover.CyclicConnectionCheck"/>.
            Also see:
            <see cref="T:SharpNeat.Graphs.Acyclic.AcyclicGraphDepthAnalysis"/>
            <see cref="T:SharpNeat.Graphs.CyclicGraphCheck"/>.
            </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck.IsConnectionCyclic(SharpNeat.Graphs.DirectedGraph,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Tests if the proposed new connection <paramref name="newConn"/> would form a cycle if added to the
            existing directed acyclic graph described by <paramref name="digraph"/>.
            </summary>
            <param name="digraph">The directed acyclic graph to run the test against.</param>
            <param name="newConn">A proposed new connection to add to the graph.</param>
            <returns>True if <paramref name="newConn"/> would form a cycle; otherwise false.</returns>
            <remarks>
            The connection source and target nodes IDs of <paramref name="newConn"/> are node indexes as
            used by the supplied digraph.
            </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck.TraverseGraph(SharpNeat.Graphs.DirectedGraph,System.Int32)">
            <summary>
            The graph traversal algorithm.
            </summary>
            <param name="digraph">The directed acyclic graph to traverse.</param>
            <param name="terminalNodeId">// The 'terminal' node ID, i.e. if traversal reaches this node
            then newConn would form a cycle and we stop/terminate traversal.</param>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.CyclicConnectionCheck.MoveForward(System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.Int32},System.Int32)">
            <summary>
            Update the stack state to point to the next connection to traverse down.
            </summary>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic">
            <summary>
            Represents an acyclic directed graph.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic.#ctor(System.Int32,System.Int32,System.Int32,SharpNeat.Graphs.ConnectionIds@,SharpNeat.Graphs.Acyclic.LayerInfo[],System.Int32[])">
            <summary>
            Construct with the given node counts, connection data, layer information, and indexes of the output nodes.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="totalNodeCount">Total node count.</param>
            <param name="connIds">The connection source and target node IDs.</param>
            <param name="layerArr">Layer information for the acyclic graph.</param>
            <param name="outputNodeIdxArr">An array containing the node index of each output node.</param>
        </member>
        <member name="P:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic.LayerArray">
            <summary>
            Layer information for the acyclic graph.
            </summary>
            <remarks>
            The nodes of the graph are arranged into layers, where the layer index (or depth) for a node is defined as the longest path
            (number of node to node hops) to arrive at that node from an input node, thus input nodes are defined as being in layer zero
            (depth 0).
            </remarks>
        </member>
        <member name="P:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic.OutputNodeIdxArr">
            <summary>
            An array containing the node index of each output node.
            </summary>
            <remarks>
            In acyclic networks the output and hidden nodes are re-ordered by network depth. This array describes
            the index of each output node in the full set of nodes. Note however that the input nodes *are* in
            their original positions, as they are defined as being at depth zero and therefore are not moved by
            the depth based sort.
            </remarks>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclicBuilderUtils">
            <summary>
            Static utility methods for building instances of <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclicBuilderUtils.CreateDirectedGraphAcyclic(SharpNeat.Graphs.DirectedGraph,SharpNeat.Graphs.Acyclic.GraphDepthInfo,System.Int32[]@,System.Int32[]@)">
            <summary>
            Creates a new directed acyclic graph instance from the provided graph structure, accompanying graph
            layer information, and node ID mappings.
            </summary>
            <param name="digraph">A directed graph structure.</param>
            <param name="depthInfo">Depth/layer information, describing what layer each node of the graph is within.</param>
            <param name="newIdByOldId">Returns a set of node ID mappings. These describe a mapping from the
            non-contiguous node ID space of <paramref name="digraph"/>, to the contiguous node ID space of the
            returned <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>
            contiguous space.</param>
            <param name="connectionIndexMap">Returns a set of connection index mappings. The connections of
            <paramref name="digraph"/> are re-ordered based on the layer/depth of each connection's source node;
            this structure conveys the new index of each connection given its original/old index.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclicBuilderUtils.CreateDirectedGraphAcyclic(SharpNeat.Graphs.DirectedGraph,SharpNeat.Graphs.Acyclic.GraphDepthInfo,System.Int32[]@,System.Int32[]@,System.Int32[]@,System.Int32[]@)">
            <summary>
            Creates a new directed acyclic graph instance from the provided graph structure, accompanying graph
            layer information, and node ID mappings.
            </summary>
            <param name="digraph">A directed graph structure.</param>
            <param name="depthInfo">Depth/layer information, describing what layer each node of the graph is within.</param>
            <param name="newIdByOldId">Returns a set of node ID mappings. These describe a mapping from the
            non-contiguous node ID space of <paramref name="digraph"/>, to the contiguous node ID space of the
            returned <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>
            contiguous space.</param>
            <param name="connectionIndexMap">Returns a set of connection index mappings. The connections of
            <paramref name="digraph"/> are re-ordered based on the layer/depth of each connection's source node;
            this structure conveys the new index of each connection given its original/old index.</param>
            <param name="timsortWorkArr">A re-usable working array for use as temporary storage by the timsort algorithm.</param>
            <param name="timsortWorkVArr">A secondary re-usable working array for use as temporary storage by the timsort algorithm.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.GraphDepthInfo">
            <summary>
            Conveys summary information from a network depth analysis.
            </summary>
        </member>
        <member name="F:SharpNeat.Graphs.Acyclic.GraphDepthInfo._graphDepth">
            <summary>
            The total depth of the graph.
            This is the highest value within _nodeDepths, + 1 (because the first layer is layer 0).
            </summary>
        </member>
        <member name="F:SharpNeat.Graphs.Acyclic.GraphDepthInfo._nodeDepthArr">
            <summary>
            An array containing the depth of each node in the digraph.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.GraphDepthInfo.#ctor(System.Int32,System.Int32[])">
            <summary>
            Construct with the provided info.
            </summary>
            <param name="graphDepth">The total depth of the graph.</param>
            <param name="nodeDepthArr">An array containing the depth of each node in the digraph.</param>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.GraphDepthInfo.Equals(SharpNeat.Graphs.Acyclic.GraphDepthInfo)">
            <summary>
            Determines whether the specified <see cref="T:SharpNeat.Graphs.Acyclic.GraphDepthInfo" /> is equal to the current <see cref="T:SharpNeat.Graphs.Acyclic.GraphDepthInfo" />.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns>true if the objects are equal; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.GraphDepthInfo.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.LayerInfo">
             <summary>
             Represents a node and connection index that represent the last node and connection in a given layer
             in an acyclic graph.
            
             The nodes and connections on an acyclic graph are ordered by the layer they are in. For more details
             on how the layers are determined/defined see <see cref="T:SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic"/>.
            
             Connections are defined as being in the same layer as their source node.
             </summary>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.LayerInfo.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="endNodeIdx">Specifies the last node in the current layer. Specifically, the index of that
            node plus one.</param>
            <param name="endConnectionIdx">Specifies the last connection in the current layer. Specifically, the index of that
            connection plus one.</param>
        </member>
        <member name="P:SharpNeat.Graphs.Acyclic.LayerInfo.EndNodeIdx">
            <summary>
            Specifies the last node in the current layer. Specifically, the index of that
            node plus one.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.Acyclic.LayerInfo.EndConnectionIdx">
            <summary>
            Specifies the last connection in the current layer. Specifically, the index of that
            connection plus one.
            </summary>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1">
            <summary>
            Represents a weighted acyclic directed graph.
            </summary>
            <typeparam name="T">Weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1.#ctor(System.Int32,System.Int32,System.Int32,SharpNeat.Graphs.ConnectionIds@,SharpNeat.Graphs.Acyclic.LayerInfo[],System.Int32[],`0[])">
            <summary>
            Construct with the given node counts, connection data, layer information, indexes of the output nodes,
            and connection weights.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="totalNodeCount">Total node count.</param>
            <param name="connIds">The connection source and target node IDs.</param>
            <param name="layerArr">Layer information for the acyclic graph.</param>
            <param name="outputNodeIdxArr">An array containing the node index of each output node.</param>
            <param name="weightArr">Connection weights array.</param>
        </member>
        <member name="P:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1.WeightArray">
            <summary>
            Connection weight array.
            </summary>
        </member>
        <member name="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclicBuilder`1">
            <summary>
            For building instances of <see cref="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclicBuilder`1.Create(System.Span{SharpNeat.Graphs.WeightedDirectedConnection{`0}},System.Int32,System.Int32)">
            <summary>
            Create with the provided list of connections, and input/output node counts.
            </summary>
            <param name="connections">A span of weighted connections that describe the graph.</param>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclicBuilder`1.Create(SharpNeat.Graphs.WeightedDirectedGraph{`0})">
            <summary>
            Create from the provided <see cref="T:SharpNeat.Graphs.WeightedDirectedGraph`1"/>.
            </summary>
            <remarks>
            The provided graph is expected to describe an acyclic graph; this method asserts that is the case and builds
            a formal acyclic graph representation.
            </remarks>
            <param name="digraph">The directed graph.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclicBuilder`1.Create(SharpNeat.Graphs.WeightedDirectedGraph{`0},SharpNeat.Graphs.Acyclic.GraphDepthInfo)">
            <summary>
            Create from the provided <see cref="T:SharpNeat.Graphs.WeightedDirectedGraph`1"/> and associated depth info.
            </summary>
            <param name="digraph">The directed graph.</param>
            <param name="depthInfo">Depth info associated with <paramref name="digraph"/>.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic`1"/>.</returns>
            <remarks>
            The provided graph is expected to describe an acyclic graph; this method asserts that is the case and builds
            a formal acyclic graph representation.
            </remarks>
        </member>
        <member name="T:SharpNeat.Graphs.ArrayNodeIdMap">
            <summary>
            An <see cref="T:SharpNeat.Graphs.INodeIdMap"/> that is backed by an array of node ID mappings. The mapping is from array index
            to the array element integer at that index, therefore the source node IDs of the mappings must be a contiguous
            sequence.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.ArrayNodeIdMap.#ctor(System.Int32[])">
            <summary>
            Construct with the given array of mappings.
            </summary>
            <param name="mapArr">An array representing node ID mappings.</param>
        </member>
        <member name="P:SharpNeat.Graphs.ArrayNodeIdMap.Count">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.ArrayNodeIdMap.Map(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.ArrayNodeIdMap.CreateInverseMap">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Graphs.ConnectionIds">
            <summary>
            Represents the connections in a directed graph.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.#ctor(System.Int32)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="length">The number of connections to allocate memory for.</param>
        </member>
        <member name="P:SharpNeat.Graphs.ConnectionIds.Length">
            <summary>
            Gets the number of connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.GetSourceIdSpan">
            <summary>
            Get a span over the connection source IDs.
            </summary>
            <returns>A <see cref="T:System.Span`1"/>"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.GetTargetIdSpan">
            <summary>
            Get a span over the connection target IDs.
            </summary>
            <returns>A <see cref="T:System.Span`1"/>"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.GetSourceId(System.Int32)">
            <summary>
            Get the source ID for the specified connection.
            </summary>
            <param name="connIdx">Connection index.</param>
            <returns>Source ID.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.GetTargetId(System.Int32)">
            <summary>
            Get the target ID for the specified connection.
            </summary>
            <param name="connIdx">Connection index.</param>
            <returns>Source ID.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionIds.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Graphs.ConnectionSorter`1">
             <summary>
             A variant on ArraySortHelper in the core framework:
            
                https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Collections/Generic/ArraySortHelper.cs
            
             This version is customised for sorting network connections. I.e. sort order is based on both source and
             target node IDs (which are held in separate arrays), and a separate array of values is re-ordered to keep
             the values at the same array index as their respective source and target IDs.
            
             This functionality could be achieved by using the various sort() methods in the core framework, but less
             efficiently than with this customised class, in terms of both speed, and also RAM allocations (and thus GC overhead).
             </summary>
             <typeparam name="T">Value data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Graphs.ConnectionSorter`1.Sort(SharpNeat.Graphs.ConnectionIds@,System.Span{`0})">
            <summary>
            Sort the connections represented by <paramref name="connIds"/>, and an accompanying values span.
            </summary>
            <param name="connIds">Represents the endpoint IDs of the connections to sort.</param>
            <param name="vals">A span of values that will have its items reordered in the same way as <paramref name="connIds"/>.</param>
        </member>
        <member name="T:SharpNeat.Graphs.CyclicGraphCheck">
             <summary>
             An algorithm for checking/testing whether a given graph is cyclic or acyclic, i.e. does a given graph have
             a connectivity cycle.
            
             Method.
             =======
             1) We loop over all nodes in the network and perform a depth-first traversal from each node.
             (Note. the order that the nodes are traversed does not affect the correctness of the method)
            
             2) Each traversal keeps track of its ancestor nodes (the path to the current node) at each step
             in the traversal. Thus if the traversal encounters an ancestor node then a cycle has been detected.
            
             3) A set of visited nodes is maintained. This persists between traversals and allows each traversal
             to avoid traversing into nodes that have already been traversed.
            
             Note. We must traverse from each node rather than just e.g. the input nodes, because the network may
             have connectivity dead ends or even isolated connectivity that therefore would not be traversed into
             by following connectivity from the input nodes only, hence we perform a traversal from each node and
             attempt to maintain algorithmic efficiency by avoiding traversal into nodes that have already been
             traversed into.
            
             The graph traversal algorithm uses function recursion. A number of other classes in SharpNEAT perform
             graph traversal by using a separate traversal stack (stored on the heap); that approach is faster but
             more complex, thus this class has not been converted to the faster approach because it is not directly
             used in the evolutionary algorithm. At time of writing this class is used only in Debug.Assert statements
             and unit tests, thus the simpler implementation is more appropriate.
             </summary>
        </member>
        <member name="M:SharpNeat.Graphs.CyclicGraphCheck.IsCyclic(SharpNeat.Graphs.DirectedGraph)">
            <summary>
            Tests a directed graph for connectivity cycles, i.e., is it cyclic or acyclic.
            </summary>
            <param name="digraph">The directed graph to test.</param>
            <returns>
            True if there is at least one connectivity cycle within the provided DirectedGraph; otherwise false.
            </returns>
        </member>
        <member name="T:SharpNeat.Graphs.CyclicGraphDepthAnalysis">
             <summary>
             An algorithm for calculating the depth of each node in an cyclic graph.
            
             Input nodes are defined as being at depth 0, and the depth of all other nodes is a determined as per the
             following scheme:
            
             Multiple separate traversals of the graph are made, one starting at each input node. Each traversal assigns
             a depth value to the visited nodes, and where a node is on multiple paths, the highest depth value is recorded.
            
             Once all traversal are complete, the average of all depths recorded against each node is calculated and rounded
             up to the nearest integer. Finally, if the scheme has resulted in empty layers (e.g. a node allocated to depth 2,
             but no nodes at depth 1) then the depth values are adjusted to remove the empty layer(s).
            
             The motivation for this slightly convoluted scheme is to create 'balanced' depth allocations when large cyclic
             loops might assign nodes very high depth values that might not be warranted, e.g. if most connections to a node
             would assign it a low depth, but a single cycle assigns it a high depth. Use of a mean/average depth is a
             compromise on the depth allocation of such a node. Median, min, or max could also be used, or indeed any aggregate
             function.
            
             The graph traversal algorithm uses function recursion. A number of other classes in SharpNEAT perform
             graph traversal by using a separate traversal stack (stored on the heap); that approach is faster but
             more complex, thus this class has not been converted to the faster approach because it is not directly
             used in the evolutionary algorithm. At time of writing this class is used only for graph visualization.
             </summary>
        </member>
        <member name="M:SharpNeat.Graphs.CyclicGraphDepthAnalysis.CalculateNodeDepths(SharpNeat.Graphs.DirectedGraph)">
            <summary>
            Calculate node depths in a cyclic network.
            </summary>
            <param name="digraph">The directed graph.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.Acyclic.GraphDepthInfo"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.DictionaryNodeIdMap">
             <summary>
             An INodeIdMap implementation based on a dictionary keyed by node ID and a fixed node count.
             </summary>
             <remarks>
             The fixed nodes count defines the identity mapping (i.e. x maps to x) for IDs from 0 to count-1,
             i.e. it's a cheap way of describing those mappings rather than including them in the dictionary,
             which is relatively expensive to populate and query.
            
             Input nodes are *always* fixed, i.e. they exist in a contiguous run of IDs starting at zero.
             In cyclic networks the output nodes are also fixed, starting directly after the input node IDs.
             In acyclic networks the outputs are not fixed, and are therefore mapped by the dictionary.
             </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.DictionaryNodeIdMap.#ctor(System.Int32,System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Construct with the given pre-built dictionary, and a fixed node count.
            </summary>
            <param name="fixedNodeCount">Fixed node count.</param>
            <param name="nodeIdxById">A pre-built dictionary of node ID to index mappings.</param>
        </member>
        <member name="P:SharpNeat.Graphs.DictionaryNodeIdMap.Count">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DictionaryNodeIdMap.Map(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DictionaryNodeIdMap.CreateInverseMap">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Graphs.DirectedConnection">
            <summary>
            Represents a connection between two nodes. Used primarily as a key into a Dictionary that
            uniquely identifies connections by their end points.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedConnection.SourceId">
            <summary>
            Connection source node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedConnection.TargetId">
            <summary>
            Connection target node ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct with the provided source and target node IDs.
            </summary>
            <param name="srcId">Connection source node ID.</param>
            <param name="tgtId">Connection target node ID.</param>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.#ctor(SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Copy constructor.
            </summary>
            <param name="copyFrom">The directed connection to copy.</param>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.Equals(SharpNeat.Graphs.DirectedConnection)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.CompareTo(SharpNeat.Graphs.DirectedConnection)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_Equality(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether two <see cref="T:SharpNeat.Graphs.DirectedConnection"/>s have the same value.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if the two <see cref="T:SharpNeat.Graphs.DirectedConnection"/>s are equal; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_Inequality(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether two <see cref="T:SharpNeat.Graphs.DirectedConnection"/>s have a different value.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if the two <see cref="T:SharpNeat.Graphs.DirectedConnection"/>s are different; otherwise false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_LessThan(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether a specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/> is less than another specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if <paramref name="x" /> is less than <paramref name="y" />; otherwise, false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_GreaterThan(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether a specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/> is greater than another specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if <paramref name="x" /> is greater than <paramref name="y" />; otherwise, false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_LessThanOrEqual(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether a specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/> is less than or equal to another specified
            <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if <paramref name="x" /> is less than <paramref name="y" />; otherwise, false.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnection.op_GreaterThanOrEqual(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.DirectedConnection@)">
            <summary>
            Determines whether a specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/> is greater than or equal to another
            specified <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.
            </summary>
            <param name="x">The first <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <param name="y">The second <see cref="T:SharpNeat.Graphs.DirectedConnection"/> to compare.</param>
            <returns>true if <paramref name="x" /> is greater than <paramref name="y" />; otherwise, false.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.DirectedConnectionUtils">
            <summary>
            Static utility methods related to working with <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnectionUtils.GetConnectionIndexBySourceNodeId(System.Span{SharpNeat.Graphs.DirectedConnection},System.Int32)">
            <summary>
            Get the index of the first connection with the given source node ID.
            </summary>
            <param name="connSpan">The span of connections to search; these must be sorted by source node ID.</param>
            <param name="srcNodeId">The source node ID to search for.</param>
            <returns>The index of the first connection with the given source node index.</returns>
            <remarks>
            If srcNodeId is not found and is less than one or more elements in array, the negative number returned is
            the bitwise complement of the index of the first connection that is larger than srcNodeId.
            If value is not found and value is greater than all connections in array, the negative number returned is the
            bitwise complement of the index of the last element plus 1.
            </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedConnectionUtils.CloneAndMap(SharpNeat.Graphs.DirectedConnection@,SharpNeat.Graphs.INodeIdMap)">
            <summary>
            Create a clone of the provided <see cref="T:SharpNeat.Graphs.DirectedConnection"/>, but with IDs mapped into a different ID space.
            </summary>
            <param name="conn">The connection to clone.</param>
            <param name="nodeIdxById">The node ID mapping.</param>
            <returns>A new <see cref="T:SharpNeat.Graphs.DirectedConnection"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.DirectedGraph">
             <summary>
             Represents a directed graph.
             </summary>
             <remarks>
             Overview
             --------
             Represents a directed graph. The graph is described by an array of connections, each with a
             source and target node ID.
            
             The node IDs are actually node indexes, i.e. if there are N unique IDs referred to in the
             connection array then the indexes run from 0 to N-1.
            
             Elsewhere in sharpneat (e.g. in a NeatGenome) graph node IDs are not necessarily contiguous,
             and thus any such graph representation must have its non-contiguous node IDs mapped to zero
             based node indexes to be represented by this class. Such node ID mapping is outside the scope
             of this class.
            
             This class can represent both cyclic or acyclic graphs, however, SharpNEAT uses it in the
             conversion of cyclic NeatGenomes only; a specialized class is used for acyclic graphs that
             gives improved runtime performance for acyclic networks.
            
             Specifics
             ---------
             The connection array is sorted by sourceIdx and secondary sorted by targetIdx. This means that all
             connections from a given node are located in a contiguous segment, the start of which can be efficiently
             located using a binary search. However to improve efficiency further, an array of lookup indexes is
             compiled, which gives the starting index of a connection span/segment for a each source node index.
             </remarks>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.#ctor(System.Int32,System.Int32,System.Int32,SharpNeat.Graphs.ConnectionIds@)">
            <summary>
            Construct with the given node counts, and connection data.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="totalNodeCount">Total node count.</param>
            <param name="connIds">The connection source and target node IDs.</param>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedGraph.InputCount">
            <summary>
            Get the input node count.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedGraph.OutputCount">
            <summary>
            Get the output node count.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedGraph.TotalNodeCount">
            <summary>
            Gets the total node count.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.DirectedGraph.ConnectionIds">
            <summary>
            The internal arrays of connection source and target node indexes. Exposed publicly for high performance scenarios.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.GetSourceNodeIdx(System.Int32)">
            <summary>
            Get the source node index of the given connection.
            </summary>
            <param name="connIdx">Connection index.</param>
            <returns>The connection's source node index.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.GetTargetNodeIdx(System.Int32)">
            <summary>
            Get the target node index of the given connection.
            </summary>
            <param name="connIdx">Connection index.</param>
            <returns>The connection's target node index.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.GetFirstConnectionIndex(System.Int32)">
            <summary>
            Get the index of the first connection with the given sourceNodeIdx.
            </summary>
            <param name="srcNodeIdx">Source node index.</param>
            <returns>The index of the first connection with the given source node index, or -1 if no such connection exists.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.GetTargetNodeIndexes(System.Int32)">
            <summary>
            Get a span of all connection target node indexes for the specified source node index.
            </summary>
            <param name="srcNodeIdx">Source node index.</param>
            <returns>A span of target nodes indexes. </returns>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraph.CompileSourceNodeConnectionIndexes">
            <summary>
            Determine the connection index that each source node's connections start at.
            </summary>
        </member>
        <member name="T:SharpNeat.Graphs.DirectedGraphBuilder">
            <summary>
            Static class for building instances of <see cref="T:SharpNeat.Graphs.DirectedGraph"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraphBuilder.Create(System.Span{SharpNeat.Graphs.DirectedConnection},System.Int32,System.Int32)">
            <summary>
            Create a directed graph based on the provided connections (between node IDs) and a predefined set of input/output
            node IDs defined as being in a contiguous sequence starting at ID zero.
            </summary>
            <param name="connections">The connections that define the structure and weights of the weighted directed graph.</param>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.DirectedGraph"/>.</returns>
            <remarks>
            <paramref name="connections"/> is required to be sorted by sourceId, TargetId.
            </remarks>
        </member>
        <member name="T:SharpNeat.Graphs.DirectedGraphBuilderUtils">
            <summary>
            Static utility methods for directed graph building.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.DirectedGraphBuilderUtils.CompileNodeIdMap(System.Int32,System.Int32[])">
            <summary>
            Create an <see cref="T:SharpNeat.Graphs.INodeIdMap"/> that provides a mapping from old to new node IDs.
            </summary>
            <param name="inputOutputCount">The total number of input and output nodes (input and output node IDs
            remain unchanged, i.e. are mapped with the identity mapping).</param>
            <param name="hiddenNodeIdArr">An array of hidden node IDs.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.DictionaryNodeIdMap"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.IActivationFunctionLibrary">
            <summary>
            Represents a library of activation functions. Primarily for use in HyperNEAT CPPNs which define
            a activation function per CPPN node.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.IActivationFunctionLibrary.GetActivationFunction``1(System.Int32)">
            <summary>
            Gets an instance of an activation function with the specified index in the library.
            </summary>
            <param name="idx">Activation function index.</param>
            <typeparam name="T">Activation function numeric data type.</typeparam>
            <returns>An instance of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/> from the library.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.IActivationFunctionLibrary.GetActivationFunction``1(System.String)">
            <summary>
            Gets an instance of an activation function with the specified ID in the library.
            </summary>
            <param name="id">Activation function ID.</param>
            <typeparam name="T">Activation function numeric data type.</typeparam>
            <returns>An instance of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/> from the library.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.INodeIdMap">
            <summary>
            Represents a mapping of graph node IDs from one ID space to another.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.INodeIdMap.Count">
            <summary>
            Gets the number of mapped node IDs.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.INodeIdMap.Map(System.Int32)">
            <summary>
            Map a node ID from the source ID space, to the target ID space.
            </summary>
            <param name="id">A node ID in the source ID space.</param>
            <returns>The mapped to ID from the target ID space.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.INodeIdMap.CreateInverseMap">
            <summary>
            Create a new <see cref="T:SharpNeat.Graphs.INodeIdMap"/> that represents the inverse of the current mapping.
            </summary>
            <returns>A new <see cref="T:SharpNeat.Graphs.INodeIdMap"/>.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.WeightedDirectedConnection`1">
            <summary>
            Represents a connection between two nodes, combined with a connection weight.
            </summary>
            <remarks>
            This type does not inherit from DirectedConnection as might be expected because these are structs (value types)
            and therefore inheritance is not possible.
            </remarks>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Graphs.WeightedDirectedConnection`1.SourceId">
            <summary>
            Connection source node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.WeightedDirectedConnection`1.TargetId">
            <summary>
            Connection target node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Graphs.WeightedDirectedConnection`1.Weight">
            <summary>
            Connection weight.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedConnection`1.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Construct with the provided source and target node IDs, and weight.
            </summary>
            <param name="srcId">Connection source node ID.</param>
            <param name="tgtId">Connection target node ID.</param>
            <param name="weight">Connection weight.</param>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedConnection`1.CompareTo(SharpNeat.Graphs.WeightedDirectedConnection{`0})">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.Graphs.WeightedDirectedConnectionComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IComparer`1"/> for comparing instances of <see cref="T:SharpNeat.Graphs.WeightedDirectedConnection`1"/>.
            </summary>
            <typeparam name="T">Connection weight numeric data type.</typeparam>
        </member>
        <member name="F:SharpNeat.Graphs.WeightedDirectedConnectionComparer`1.Default">
            <summary>
            Singleton instance.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedConnectionComparer`1.Compare(SharpNeat.Graphs.WeightedDirectedConnection{`0},SharpNeat.Graphs.WeightedDirectedConnection{`0})">
            <summary>
            Compares two instances of <see cref="T:SharpNeat.Graphs.WeightedDirectedConnection`1"/> and returns a value indicating
            whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />.</returns>
        </member>
        <member name="T:SharpNeat.Graphs.WeightedDirectedGraph`1">
             <summary>
             Overview
             --------
             Represents a weighted directed graph. The graph is described by an array of connections,
             each with a source and target node ID and a weight.
            
             The node IDs are actually node indexes, i.e. if there are N unique IDs referred to in the
             connection array then the indexes run from 0 to N-1. An exception to this is when representing
             graphs from a NeatGenome in which input and outputs nodes are given fixed IDs regardless of whether
             they are connected to or not, however the use of a contiguous range of node indexes starting at zero
             still holds in that case.
            
             Elsewhere in sharpneat (e.g. in a NeatGenome) graph node IDs are not necessarily contiguous,
             and thus any such graph representation must have its non-contiguous node IDs mapped to zero
             based node indexes to be represented by this class. Such node ID mapping is outside the scope
             of this class.
            
             This class can represent both cyclic or acyclic graphs, however, SharpNEAT uses it in the
             conversion of cyclic NeatGenomes only; a specialized class is used for acyclic graphs that
             gives improved runtime performance for acyclic networks.
            
             Specifics
             ---------
             The connection array is sorted by sourceID and secondary sorted by targetID. This means that all
             connections from a given node are located in a contiguous segment, the start of which can be efficiently
             located using a binary search. However to improve efficiency further an array of lookup indexes is compiled
             which gives the starting index of a connection span/segment for a given source node index.
             </summary>
             <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="P:SharpNeat.Graphs.WeightedDirectedGraph`1.WeightArray">
            <summary>
            Connection weight array.
            </summary>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedGraph`1.#ctor(System.Int32,System.Int32,System.Int32,SharpNeat.Graphs.ConnectionIds@,`0[])">
            <summary>
            Construct with the given node counts, connection data, and connection weights.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="totalNodeCount">Total node count.</param>
            <param name="connIds">The connection source and target node IDs.</param>
            <param name="weightArr">Connection weights array.</param>
        </member>
        <member name="T:SharpNeat.Graphs.WeightedDirectedGraphBuilder`1">
            <summary>
            For building instances of <see cref="T:SharpNeat.Graphs.WeightedDirectedGraph`1"/>.
            </summary>
            <typeparam name="T">Connection weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedGraphBuilder`1.Create(System.Span{SharpNeat.Graphs.WeightedDirectedConnection{`0}},System.Int32,System.Int32)">
            <summary>
            Create a directed graph based on the provided connections (between node IDs) and a predefined set of node IDs.
            Clearly the set of nodeIDs could be discovered by iterating over the connections. This overload exists to allow
            for additional fixed node IDs to be allocated regardless of whether they are connected to or not, this is primarily
            to allow for the allocation of NeatGenome input and output nodes, which are defined with fixed IDs but aren't
            necessarily connected to.
            </summary>
            <param name="connections">The connections that define the structure and weights of the weighted directed graph.</param>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <returns>A new instance of <see cref="T:SharpNeat.Graphs.WeightedDirectedGraph`1"/>.</returns>
        </member>
        <member name="M:SharpNeat.Graphs.WeightedDirectedGraphBuilder`1.CopyAndMapIds(System.Span{SharpNeat.Graphs.WeightedDirectedConnection{`0}},SharpNeat.Graphs.INodeIdMap,SharpNeat.Graphs.ConnectionIds@,`0[]@)">
            <summary>
            Split each IWeightedDirectedConnection in a list into an array of DirectedConnections(s), and an array of weights.
            Map the node IDs to indexes as we go.
            </summary>
        </member>
        <member name="T:SharpNeat.IBlackBox`1">
             <summary>
             Represents an abstract 'black box' function, with an input vector, and an Activate() method that takes
             the inputs to produce an output vector. I.e. 'black box' here could also be described as a multivariate
             mathematical function.
            
             Typically a black box will be a neural network, whereby we set the input vector, activate the network, and
             read its output vector. However, in principle a black box could be any kind of function or information processing
             system such as a C# program or a genetic programming tree.
             </summary>
             <typeparam name="T">Black box numeric data type.</typeparam>
        </member>
        <member name="P:SharpNeat.IBlackBox`1.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.IBlackBox`1.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.IBlackBox`1.Activate">
            <summary>
            Activate the black box. This causes the black box to accept its inputs and produce output signals
            ready for reading from OutputVector.
            </summary>
        </member>
        <member name="M:SharpNeat.IBlackBox`1.Reset">
            <summary>
            Reset any internal state.
            </summary>
        </member>
        <member name="T:SharpNeat.IO.FileFormatException">
            <summary>
            Thrown when a file has an invalid format.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.FileFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpNeat.IO.FileFormatException"/> class.
            </summary>
            <param name="message">A message describing why this exception was thrown.</param>
        </member>
        <member name="M:SharpNeat.IO.FileFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpNeat.IO.FileFormatException"/> class.
            </summary>
            <param name="message">A message describing why this exception was thrown.</param>
            <param name="innerException">The inner exception that caused this ConfigurationException to be thrown,
            if any.</param>
        </member>
        <member name="T:SharpNeat.IO.JsonUtils">
            <summary>
            Static utility methods for loading JSON.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.JsonUtils.DeserializeFromFile``1(System.String)">
            <summary>
            Read JSON from the provided file, and deserialize into type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to deserialize to.</typeparam>
            <param name="filename">The name of the filename to read the JSOn from.</param>
            <returns>A new instance of T.</returns>
        </member>
        <member name="M:SharpNeat.IO.JsonUtils.Deserialize``1(System.IO.Stream)">
            <summary>
            Read JSON from the provided stream, and deserialize into type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to deserialize to.</typeparam>
            <param name="utf8Json">An input stream from which json can be read from.</param>
            <returns>A new instance of T.</returns>
        </member>
        <member name="M:SharpNeat.IO.JsonUtils.Deserialize``1(System.String)">
            <summary>
            Read JSON from the provided string, and deserialize into type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to deserialize to.</typeparam>
            <param name="json">A string containing json.</param>
            <returns>A new instance of T.</returns>
        </member>
        <member name="T:SharpNeat.IO.Models.ActivationFnLine">
            <summary>
            Represents an activation function line in a 'net' file.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.ActivationFnLine.Id">
            <summary>
            Activation function ID.
            </summary>
            <remarks>Function IDs are integers and are always defined in a continuous sequence starting at zero.</remarks>
        </member>
        <member name="P:SharpNeat.IO.Models.ActivationFnLine.Code">
            <summary>
            Activation function code.
            </summary>
            <remarks>
            The code is a string identifier such as 'ReLU' or 'Logistic'.
            These code correspond with the local class names (i.e. not including the namespace) of the activation function implementations.</remarks>
        </member>
        <member name="M:SharpNeat.IO.Models.ActivationFnLine.#ctor(System.Int32,System.String)">
            <summary>
            Construct a new instance.
            </summary>
            <param name="id">ID.</param>
            <param name="code">Code.</param>
        </member>
        <member name="T:SharpNeat.IO.Models.ConnectionLine">
            <summary>
            Represents a connection line in a 'net' file.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.ConnectionLine.SourceId">
            <summary>
            Connection source node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.ConnectionLine.TargetId">
            <summary>
            Connection target node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.ConnectionLine.Weight">
            <summary>
            Connection weight.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.Models.ConnectionLine.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Construct with the provided source and target node IDs, and weight.
            </summary>
            <param name="srcId">Connection source node ID.</param>
            <param name="tgtId">Connection target node ID.</param>
            <param name="weight">Connection weight.</param>
        </member>
        <member name="T:SharpNeat.IO.Models.NetFileModel">
            <summary>
            An object model that represents instances of the 'net' file format.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.InputCount">
            <summary>
            Input node count.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.OutputCount">
            <summary>
            Output node count.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.IsAcyclic">
            <summary>
            Indicates of the graph/network is acyclic.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.CyclesPerActivation">
            <summary>
            For cyclic networks, this specifies the number of timesteps are run per activation of the network. Not
            used when <see cref="P:SharpNeat.IO.Models.NetFileModel.IsAcyclic"/> is true.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.Connections">
            <summary>
            A list of sourceId-targetId-weight tuples, that together describe the graph/network.
            </summary>
        </member>
        <member name="P:SharpNeat.IO.Models.NetFileModel.ActivationFns">
            <summary>
            A list of activations functions.
            </summary>
            <remarks>
            Each line contains an integer ID and a code (e.g. 'ReLU').
            The IDs are integers and are always defined in a continuous sequence starting at zero.
            Currently only one line is allowed, and this describes the activation function to use for all nodes in the
            network.
            </remarks>
        </member>
        <member name="M:SharpNeat.IO.Models.NetFileModel.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32,System.Collections.Generic.List{SharpNeat.IO.Models.ConnectionLine},System.Collections.Generic.List{SharpNeat.IO.Models.ActivationFnLine})">
            <summary>
            Initialises a new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="isAcyclic">Indicates of the graph/network is acyclic.</param>
            <param name="cyclesPerActivation">For cyclic networks, this specifies the number of timesteps are run per activation of the network.</param>
            <param name="connList">A list of sourceId-targetId-weight tuples, that together describe the graph/network.</param>
            <param name="activationFns">A list of activations functions.</param>
        </member>
        <member name="M:SharpNeat.IO.Models.NetFileModel.CreateAcyclic(System.Int32,System.Int32,System.Collections.Generic.List{SharpNeat.IO.Models.ConnectionLine},System.Collections.Generic.List{SharpNeat.IO.Models.ActivationFnLine})">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>, representing an acyclic network.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="connList">A list of sourceId-targetId-weight tuples, that together describe the graph/network.</param>
            <param name="activationFns">A list of activations functions.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="M:SharpNeat.IO.Models.NetFileModel.CreateCyclic(System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{SharpNeat.IO.Models.ConnectionLine},System.Collections.Generic.List{SharpNeat.IO.Models.ActivationFnLine})">
            <summary>
            Create a new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>, representing an cyclic network.
            </summary>
            <param name="inputCount">Input node count.</param>
            <param name="outputCount">Output node count.</param>
            <param name="cyclesPerActivation">For cyclic networks, this specifies the number of timesteps are run per activation of the network.</param>
            <param name="connList">A list of sourceId-targetId-weight tuples, that together describe the graph/network.</param>
            <param name="activationFns">A list of activations functions.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="T:SharpNeat.IO.NetFile">
            <summary>
            Static methods for loading and saving instances of <see cref="T:SharpNeat.IO.Models.NetFileModel"/> from and to a file.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.NetFile.Load(System.String)">
            <summary>
            Load a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance from a 'net' format file.
            </summary>
            <param name="filepath">The name and path of the file to load.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="M:SharpNeat.IO.NetFile.Load(System.IO.Stream)">
            <summary>
            Load a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance from a 'net' format file.
            </summary>
            <param name="stream">The stream to read from.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="M:SharpNeat.IO.NetFile.Save(SharpNeat.IO.Models.NetFileModel,System.String)">
            <summary>
            Save a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to file using 'net' file format.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to save.</param>
            <param name="filepath">The name and path of the file to save to.</param>
        </member>
        <member name="M:SharpNeat.IO.NetFile.Save(SharpNeat.IO.Models.NetFileModel,System.IO.Stream)">
            <summary>
            Save a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to a stream using 'net' file format.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to save.</param>
            <param name="stream">The stream to save to.</param>
        </member>
        <member name="T:SharpNeat.IO.NetFileReader">
            <summary>
            For reading of 'net' format files.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.NetFileReader.Read(System.IO.StreamReader)">
            <summary>
            Read a 'net' format file from a stream reader.
            </summary>
            <param name="sr">The stream reader to read from.</param>
            <returns>A new instance of <see cref="T:SharpNeat.IO.Models.NetFileModel"/>.</returns>
        </member>
        <member name="T:SharpNeat.IO.NetFileWriter">
            <summary>
            For writing of 'net' format files.
            </summary>
        </member>
        <member name="M:SharpNeat.IO.NetFileWriter.Write(SharpNeat.IO.Models.NetFileModel,System.IO.StreamWriter)">
            <summary>
            Write a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a stream writer using the 'net' file format.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to write.</param>
            <param name="sw">The stream writer to write to.</param>
        </member>
        <member name="T:SharpNeat.NeuralNets.ActivationFunctionId">
            <summary>
            The set of neural network activation functions provided as standard in SharpNEAT.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.ArcSinH">
            <summary>
            The ArcSinH function (inverse hyperbolic sine function).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.ArcTan">
            <summary>
            The ArcTan function (inverse tangent function).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.LeakyReLU">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.LeakyReLUShifted">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.Logistic">
            <summary>
            The logistic function.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.LogisticApproximantSteep">
            <summary>
            The logistic function with a steepened slope, and implemented using a fast to compute approximation of exp().
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.LogisticSteep">
            <summary>
            The logistic function with a steepened slope.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.MaxMinusOne">
            <summary>
            max(-1, x,) function.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.NullFn">
            <summary>
            Null activation function. Returns zero regardless of input.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.PolynomialApproximantSteep">
            <summary>
            A very close approximation of the logistic function that avoids use of exp() and is therefore
            typically much faster to compute, while giving an almost identical sigmoid curve.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.QuadraticSigmoid">
            <summary>
            A sigmoid formed by two sub-sections of the y=x^2 curve.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.ReLU">
            <summary>
            Rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.ScaledELU">
            <summary>
            Scaled Exponential Linear Unit (SELU).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.SoftSignSteep">
            <summary>
            The softsign sigmoid.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.SReLU">
            <summary>
            S-shaped rectified linear activation unit (SReLU).
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.SReLUShifted">
            <summary>
            S-shaped rectified linear activation unit (SReLU). Shifted on the x-axis so that x=0 gives y=0.5, in keeping with the logistic sigmoid.
            </summary>
        </member>
        <member name="F:SharpNeat.NeuralNets.ActivationFunctionId.TanH">
            <summary>
            TanH function (hyperbolic tangent function).
            </summary>
        </member>
        <member name="T:SharpNeat.NeuralNets.DefaultActivationFunctionFactory`1">
             <summary>
             Default implementation of <see cref="T:SharpNeat.NeuralNets.IActivationFunctionFactory`1"/>.
            
             A factory class for obtaining instances of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/>.
             </summary>
             <typeparam name="T">Neural net signal and weight data type.</typeparam>
        </member>
        <member name="M:SharpNeat.NeuralNets.DefaultActivationFunctionFactory`1.#ctor(System.Boolean)">
            <summary>
            Construct with the provided options.
            </summary>
            <param name="enableHardwareAcceleration">If true then hardware accelerated activation functions are used when available.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.DefaultActivationFunctionFactory`1.GetActivationFunction(System.String)">
            <summary>
            Get an activation function instance for the given activation function name/ID.
            </summary>
            <param name="name">Activation function name/ID.</param>
            <returns>An instance of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH">
            <summary>
            The ArcSinH function (inverse hyperbolic sine function).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcSinH.Asinh(System.Double)">
            <summary>
            Hyperbolic Area Sine.
            </summary>
            <param name="x">The real value.</param>
            <returns>The hyperbolic angle, i.e. the area of its hyperbolic sector.</returns>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan">
            <summary>
            The ArcTan function (inverse tangent function).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ArcTan.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian">
            <summary>
            Bipolar Gaussian activation function. Output range is -1 to 1, that is, the tails of the Gaussian
            distribution curve tend towards -1 as abs(x) -> Infinity and the Gaussian peak is at y = 1.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarGaussian.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid">
            <summary>
            Bipolar sigmoid activation function. Output range is -1 to 1 instead of the more normal 0 to 1.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.BipolarSigmoid.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian">
            <summary>
            Gaussian activation function. Output range is 0 to 1, that is, the tails of the Gaussian
            distribution curve tend towards 0 as abs(x) -> Infinity and the Gaussian peak is at x = 0.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Gaussian.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear">
            <summary>
            Linear activation function with clipping. By 'clipping' we mean the output value is linear between
            x = -1 and x = 1. Below -1 and above +1 the output is clipped at -1 and +1 respectively.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Linear.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine">
            <summary>
            Sine activation function with doubled period.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Cppn.Sine.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            Shifted on the x-axis so that x=0 gives y=0.5, in keeping with the logistic sigmoid.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LeakyReLUShifted.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic">
            <summary>
            The logistic function.
            <see href="http://en.wikipedia.org/wiki/Logistic_function"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Logistic.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep">
            <summary>
            The logistic function with a steepened slope, and implemented using a fast to compute approximation of exp().
            See:
              https://stackoverflow.com/a/412988/15703
              https://pdfs.semanticscholar.org/35d3/2b272879a2018a2d33d982639d4be489f789.pdf (A Fast, Compact Approximation of the Exponential Function).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticApproximantSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep">
            <summary>
            The logistic function with a steepened slope.
            <see href="http://en.wikipedia.org/wiki/Logistic_function"/>.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.LogisticSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne">
            <summary>
            max(-1, x,) function.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.MaxMinusOne.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn">
            <summary>
            Null activation function. Returns zero regardless of input.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.NullFn.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep">
             <summary>
             A very close approximation of the logistic function that avoids use of exp() and is therefore
             typically much faster to compute, while giving an almost identical sigmoid curve.
            
             This function was obtained from:
                http://stackoverflow.com/a/34448562/15703
            
            
             This might be based on the Pade approximant:
               https://en.wikipedia.org/wiki/Pad%C3%A9_approximant
               https://math.stackexchange.com/a/107666
            
             Or perhaps the maple minimax approximation:
               http://www.maplesoft.com/support/helpJP/Maple/view.aspx?path=numapprox/minimax
            
             This is a variant that has a steeper slope at and around the origin that is intended to be a similar
             slope to that of LogisticFunctionSteep.
            
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.PolynomialApproximantSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid">
             <summary>
             A sigmoid formed by two sub-sections of the y=x^2 curve.
            
             The extremes are implemented as per the leaky ReLU, i.e. there is a linear slop to
             ensure there is at least a gradient to follow at the extremes.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.QuadraticSigmoid.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU">
            <summary>
            Rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU">
             <summary>
             Scaled Exponential Linear Unit (SELU).
            
             From:
                 Self-Normalizing Neural Networks
                 https://arxiv.org/abs/1706.02515
            
             Original source code (including parameter values):
                 <see href="https://github.com/bioinf-jku/SNNs/blob/master/selu.py"/>.
            
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.ScaledELU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep">
            <summary>
            The softsign sigmoid.
            This is a variant of softsign that has a steeper slope at and around the origin that
            is intended to be a similar slope to that of LogisticFunctionSteep.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SoftSignSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU">
            <summary>
            S-shaped rectified linear activation unit (SReLU).
            From:
               https://en.wikipedia.org/wiki/Activation_function
               https://arxiv.org/abs/1512.07030 [Deep Learning with S-shaped Rectified Linear Activation Units].
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted">
            <summary>
            S-shaped rectified linear activation unit (SReLU).
            Shifted on the x-axis so that x=0 gives y=0.5, in keeping with the logistic sigmoid.
            From:
               https://en.wikipedia.org/wiki/Activation_function
               https://arxiv.org/abs/1512.07030 [Deep Learning with S-shaped Rectified Linear Activation Units].
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.SReLUShifted.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH">
            <summary>
            TanH function (hyperbolic tangent function).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.TanH.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted">
            <summary>
            Leaky rectified linear activation unit (ReLU).
            Shifted on the x-axis so that x=0 gives y=0.5, in keeping with the logistic sigmoid.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.LeakyReLUShifted.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne">
            <summary>
            max(-1, x,) function.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.MaxMinusOne.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep">
             <summary>
             A very close approximation of the logistic function that avoids use of exp() and is therefore
             typically much faster to compute, while giving an almost identical sigmoid curve.
            
             This function was obtained from:
                http://stackoverflow.com/a/34448562/15703
            
            
             This might be based on the Pade approximant:
               https://en.wikipedia.org/wiki/Pad%C3%A9_approximant
               https://math.stackexchange.com/a/107666
            
             Or perhaps the maple minimax approximation:
               http://www.maplesoft.com/support/helpJP/Maple/view.aspx?path=numapprox/minimax
            
             This is a variant that has a steeper slope at and around the origin that is intended to be a similar
             slope to that of LogisticFunctionSteep.
            
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.PolynomialApproximantSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid">
             <summary>
             A sigmoid formed by two sub-sections of the y=x^2 curve.
            
             The extremes are implemented as per the leaky ReLU, i.e. there is a linear slop to
             ensure there is at least a gradient to follow at the extremes.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.QuadraticSigmoid.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU">
            <summary>
            Rectified linear activation unit (ReLU).
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.ReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep">
            <summary>
            The softsign sigmoid.
            This is a variant of softsign that has a steeper slope at and around the origin that
            is intended to be a similar slope to that of LogisticFunctionSteep.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SoftSignSteep.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU">
            <summary>
            S-shaped rectified linear activation unit (SReLU).
            From:
               https://en.wikipedia.org/wiki/Activation_function
               https://arxiv.org/abs/1512.07030 [Deep Learning with S-shaped Rectified Linear Activation Units].
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLU.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted">
            <summary>
            S-shaped rectified linear activation unit (SReLU).
            Shifted on the x-axis so that x=0 gives y=0.5, in keeping with the logistic sigmoid.
            From:
               https://en.wikipedia.org/wiki/Activation_function
               https://arxiv.org/abs/1512.07030 [Deep Learning with S-shaped Rectified Linear Activation Units].
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.Double@,System.Double@)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.ReadOnlySpan{System.Double},System.Span{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.ActivationFunctions.Vectorized.SReLUShifted.Fn(System.Double@,System.Double@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclic">
             <summary>
             A neural network implementation for acyclic networks.
            
             Activation of acyclic networks can be far more efficient than cyclic networks because we can activate the network by
             propagating a signal 'wave' from the input nodes through each layer to the output nodes, thus each node
             requires activation only once at most, whereas in cyclic networks we must (a) activate each node multiple times and
             (b) have a scheme that defines when to stop activating the network.
            
             Algorithm Overview.
             1) The nodes are assigned a depth number based on how many connection hops they are from an input node. Where multiple
             paths to a node exist the longest path determines the node's depth.
            
             2) Connections are similarly assigned a depth value which is defined as the depth of a connection's source node.
            
             Note. Steps 1 and 2 are actually performed by AcyclicNetworkFactory.
            
             3) Reset all node activation values to zero. This resets any state from a previous activation.
            
             4) Each layer of the network can now be activated in turn to propagate the signals on the input nodes through the network.
             Input nodes do no apply an activation function so we start by activating the connections on the first layer (depth == 0),
             this accumulates node pre-activation signals on all of the target nodes which can be anywhere from depth 1 to the highest
             depth level. Having done this we apply the node activation function for all nodes at the layer 1 because we can now
             guarantee that there will be no more incoming signals to those nodes. Repeat for all remaining layers in turn.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.#ctor(SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic{System.Double},SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.#ctor(SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic,System.Double[],SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="weightArr">Connection weights array.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.Activate">
            <summary>
            Activate the network. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclic.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe">
             <summary>
             This class is functionally equivalent to <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclic"/>, but doesn't use any of the unsafe
             memory pointer techniques used in that class, and therefore this class is much slower.
            
             This class is intended to be used as a safe reference implementation that can be used when testing or
             debugging <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclic"/>.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.#ctor(SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic{System.Double},SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.#ctor(SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic,System.Double[],SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="weightArr">Connection weights array.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.Activate">
            <summary>
            Activate the network. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetAcyclicSafe.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.NeuralNetCyclic">
             <summary>
             A neural network class that represents a network with recurrent (cyclic) connections.
            
             Algorithm Overview.
             1) Loop connections.
             Each connection gets its input signal from its source node, multiplies the signal by its weight, and adds
             the result to its target node's pre-activation variable. Connections are ordered by source node index,
             thus all memory reads are sequential, but the memory writes to node pre-activation variables are
             non-sequential.
            
             2) Loop nodes.
             Pass each node's pre-activation signal through the activation function, storing the result in a separate
             post-activation signals array.
            
             3) Completion.
             Copy the post-activation signals into the pre-activations signals array.
            
             The activation loop is run a fixed number of times/cycles to allow signals to gradually propagate through
             the network, one timestep/cycle/loop at a time.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclic.#ctor(SharpNeat.Graphs.WeightedDirectedGraph{System.Double},SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The weighted directed graph that defines the neural network structure and connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclic.#ctor(SharpNeat.Graphs.DirectedGraph,System.Double[],SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The directed graph that defines the neural network structure.</param>
            <param name="weightArr">An array of neural network connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetCyclic.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetCyclic.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclic.Activate">
            <summary>
            Activate the network for a fixed number of iterations defined by the 'maxIterations' parameter
            at construction time. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclic.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclic.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe">
             <summary>
             This class is functionally equivalent to <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetCyclic"/>, but doesn't use any of the unsafe
             memory pointer techniques used in that class, and therefore this class is much slower.
            
             This class is intended to be used as a safe reference implementation that can be used when testing or
             debugging <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetCyclic"/>.
             </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.#ctor(SharpNeat.Graphs.WeightedDirectedGraph{System.Double},SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The weighted directed graph that defines the neural network structure and connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.#ctor(SharpNeat.Graphs.DirectedGraph,System.Double[],SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The directed graph that defines the neural network structure.</param>
            <param name="weightArr">An array of neural network connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.Activate">
            <summary>
            Activate the network for a fixed number of iterations defined by the 'maxIterations' parameter
            at construction time. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.NeuralNetCyclicSafe.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic">
            <summary>
            A version of <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetAcyclic"/> that utilises some vectorized operations
            for improved performance on hardware platforms that support them.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.#ctor(SharpNeat.Graphs.Acyclic.WeightedDirectedGraphAcyclic{System.Double},SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.#ctor(SharpNeat.Graphs.Acyclic.DirectedGraphAcyclic,System.Double[],SharpNeat.NeuralNets.VecFn{System.Double})">
            <summary>
            Constructs a AcyclicNeuralNet with the provided neural net definition parameters.
            </summary>
            <param name="digraph">Network structure definition.</param>
            <param name="weightArr">Connection weights array.</param>
            <param name="activationFn">Node activation function.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.Activate">
            <summary>
            Activate the network. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetAcyclic.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic">
            <summary>
            A version of <see cref="T:SharpNeat.NeuralNets.Double.NeuralNetCyclic"/> that utilises some vectorized operations
            for improved performance on hardware platforms that support them.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.#ctor(SharpNeat.Graphs.WeightedDirectedGraph{System.Double},SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The weighted directed graph that defines the neural network structure and connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.#ctor(SharpNeat.Graphs.DirectedGraph,System.Double[],SharpNeat.NeuralNets.VecFn2{System.Double},System.Int32)">
            <summary>
            Constructs a cyclic neural network.
            </summary>
            <param name="digraph">The directed graph that defines the neural network structure.</param>
            <param name="weightArr">An array of neural network connection weights.</param>
            <param name="activationFn">The neuron activation function to use at all neurons in the network.</param>
            <param name="cyclesPerActivation">The number of activation cycles to perform per overall activation of the cyclic network.</param>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.Inputs">
            <summary>
            Gets a memory segment that represents a vector of input values.
            </summary>
        </member>
        <member name="P:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.Outputs">
            <summary>
            Gets a memory segment that represents a vector of output values.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.Activate">
            <summary>
            Activate the network for a fixed number of iterations defined by the 'maxIterations' parameter
            at construction time. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.Reset">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.Double.Vectorized.NeuralNetCyclic.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:SharpNeat.NeuralNets.VecFn`1">
            <summary>
            The activation function.
            </summary>
            <param name="vref">>A reference to the head of a span containing pre-activation levels to pass through the function.
            The resulting post-activation levels are written back to this same span.</param>
            <param name="len">The length of the span, i.e., the number elements in the span.</param>
            <typeparam name="T">Activation function numeric data type.</typeparam>
        </member>
        <member name="T:SharpNeat.NeuralNets.VecFn2`1">
            <summary>
            The activation function; unsafe memory span implementation with a separate input and output spans.
            </summary>
            <param name="vref">A reference to the head of a span containing pre-activation levels to pass through the function.</param>
            <param name="wref">A reference to the head of a span in which the post-activation levels are stored.</param>
            <param name="len">The length of the spans, i.e., the number elements in the spans.</param>
            <typeparam name="T">Activation function numeric data type.</typeparam>
        </member>
        <member name="T:SharpNeat.NeuralNets.IActivationFunction`1">
            <summary>
            Represents a node/neuron activation function.
            </summary>
            <typeparam name="T">Activation function numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(`0@)">
            <summary>
            The activation function; scalar implementation, accepting a single variable reference.
            The pre-activation level is read from <paramref name="x"/>; the post-activation result is stored to
            the same variable.
            </summary>
            <param name="x">The variable reference.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(`0@,`0@)">
            <summary>
            The activation function; scalar implementation, accepting a single variable reference.
            The pre-activation level is read from <paramref name="x"/>; the post-activation result is stored to
            <paramref name="y"/>.
            </summary>
            <param name="x">The pre-activation variable reference.</param>
            <param name="y">The post-activation variable reference.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(System.Span{`0})">
            <summary>
            The activation function; span implementation.
            </summary>
            <param name="v">A span of pre-activation levels to pass through the function.
            The resulting post-activation levels are written back to this same span.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(System.ReadOnlySpan{`0},System.Span{`0})">
            <summary>
            The activation function; span implementation with a separate input and output spans.
            </summary>
            <param name="v">A span of pre-activation levels to pass through the function.</param>
            <param name="w">A span in which the post-activation levels are stored.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(`0@,System.Int32)">
            <summary>
            The activation function; unsafe memory span implementation.
            </summary>
            <param name="vref">A reference to the head of a span containing pre-activation levels to pass through the function.
            The resulting post-activation levels are written back to this same span.</param>
            <param name="len">The length of the span, i.e., the number elements in the span.</param>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunction`1.Fn(`0@,`0@,System.Int32)">
            <summary>
            The activation function; unsafe memory span implementation with separate input and output spans.
            </summary>
            <param name="vref">A reference to the head of a span containing pre-activation levels to pass through the function.</param>
            <param name="wref">A reference to the head of a span in which the post-activation levels are stored.</param>
            <param name="len">The length of the spans, i.e., the number elements in the spans.</param>
        </member>
        <member name="T:SharpNeat.NeuralNets.IActivationFunctionFactory`1">
            <summary>
            Represents a factory for obtaining instances of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/>.
            </summary>
            <typeparam name="T">Neural net numeric data type.</typeparam>
        </member>
        <member name="M:SharpNeat.NeuralNets.IActivationFunctionFactory`1.GetActivationFunction(System.String)">
            <summary>
            Get an activation function instance for the given activation function name/ID.
            </summary>
            <param name="name">Activation function name/ID.</param>
            <returns>An instance of <see cref="T:SharpNeat.NeuralNets.IActivationFunction`1"/>.</returns>
        </member>
        <member name="T:SharpNeat.NeuralNets.IO.NeuralNetConverter">
            <summary>
            Static methods for converting <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a neural network instance.
            </summary>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToNeuralNet(SharpNeat.IO.Models.NetFileModel,System.Boolean,System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a neural network instance.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <param name="enableHardwareAcceleratedActivationFunctions">If true then hardware accelerated activation
            functions are used, where available.</param>
            <returns>A new neural net instance.</returns>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToNeuralNet(SharpNeat.IO.Models.NetFileModel,SharpNeat.NeuralNets.IActivationFunctionFactory{System.Double},System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a neural network instance.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="activationFnLib">Activation function library.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <returns>A new neural net instance.</returns>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToAcyclicNeuralNet(SharpNeat.IO.Models.NetFileModel,System.Boolean,System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to an acyclic neural network instance.
            </summary>
            /// <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <param name="enableHardwareAcceleratedActivationFunctions">If true then hardware accelerated activation
            functions are used, where available.</param>
            <returns>A new acyclic neural net instance.</returns>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToAcyclicNeuralNet(SharpNeat.IO.Models.NetFileModel,SharpNeat.NeuralNets.IActivationFunctionFactory{System.Double},System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to an acyclic neural network instance.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="activationFnLib">Activation function library.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <returns>A new acyclic neural net instance.</returns>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToCyclicNeuralNet(SharpNeat.IO.Models.NetFileModel,System.Boolean,System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a cyclic neural network instance.
            </summary>
            /// <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <param name="enableHardwareAcceleratedActivationFunctions">If true then hardware accelerated activation
            functions are used, where available.</param>
            <returns>A new cyclic neural net instance.</returns>
        </member>
        <member name="M:SharpNeat.NeuralNets.IO.NeuralNetConverter.ToCyclicNeuralNet(SharpNeat.IO.Models.NetFileModel,SharpNeat.NeuralNets.IActivationFunctionFactory{System.Double},System.Boolean)">
            <summary>
            Convert a <see cref="T:SharpNeat.IO.Models.NetFileModel"/> to a cyclic neural network instance.
            </summary>
            <param name="model">The <see cref="T:SharpNeat.IO.Models.NetFileModel"/> instance to convert from.</param>
            <param name="activationFnLib">Activation function library.</param>
            <param name="enableHardwareAcceleratedNeuralNets">If true then hardware accelerated neural net
            implementations are used.</param>
            <returns>A new cyclic neural net instance.</returns>
        </member>
    </members>
</doc>
